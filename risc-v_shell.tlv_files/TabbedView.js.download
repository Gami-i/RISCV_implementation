(function() {
  var $, BladeComponent, FlexSplit, Logging, Promise, TabbedView, Utils, ref,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty,
    slice = [].slice;

  ref = [], BladeComponent = ref[0], FlexSplit = ref[1], $ = ref[2], Utils = ref[3], Promise = ref[4], Logging = ref[5];


  /*
  A module that describes a tabbed layout, with multiple panels inside.
  
  @extend BladeComponent
  @extend ModuleConfigObject
  @extend FlexSplit.Child
   */

  TabbedView = (function() {
    var el, ref1, status;

    function TabbedView() {
      this.initSortable = bind(this.initSortable, this);
    }

    TabbedView.allTabbedViews = {};

    TabbedView.paneID = 0;

    TabbedView.allPanes = {};

    TabbedView.prototype.lastid = null;

    TabbedView.prototype.path = null;

    TabbedView.prototype.panes = null;

    TabbedView.prototype.tabbedviewEl = null;

    TabbedView.prototype.tabContainer = null;

    TabbedView.prototype.paneContainer = null;

    TabbedView.prototype.activePane = null;

    TabbedView.prototype.splitSide = null;

    TabbedView.prototype.containingSplit = null;


    /*
    A Font-Awesome status DOM element.
    @param {String} icon Eg, " fa-circle" for .fa.fa-fw.fa-circle
    @param {String} style the style attribute for the icon or null
    @return the DOM element.
     */

    TabbedView._faStatusEl = function(icon, style) {
      var el;
      el = document.createElement("I");
      el.setAttribute("class", "fa fa-fw" + icon);
      return el;
    };

    TabbedView.statusEl = {
      none: TabbedView._faStatusEl(""),
      success: TabbedView._faStatusEl(" fa-check"),
      fail: TabbedView._faStatusEl(" fa-times"),
      timeout: TabbedView._faStatusEl(" fa-clock-o"),
      working: TabbedView._faStatusEl(" fa-spinner fa-pulse"),
      outdated: (function() {
        var el, iconEl;
        iconEl = TabbedView._faStatusEl(" fa-circle");
        el = document.createElement("SPAN");
        el.appendChild(iconEl);
        el.appendChild(TabbedView._faStatusEl(""));
        return el;
      })()
    };

    ref1 = TabbedView.statusEl;
    for (status in ref1) {
      el = ref1[status];
      el.className += " status-el";
    }


    /*
    Initialize
    @param {String} path The path for this component.
    @param {"left", "top", "right", "bottom", "center"} side The side this {TabbedView} is within in its parent.
    @param {FlexSplit} parent The {FlexSplit} in which this {TabbedView} is to be contained.
    @return {Promise} Resolve to this.
     */

    TabbedView.prototype.init = function(path, side, parent) {
      this.path = path;
      this.parent = parent;
      this.panes = {};
      this.intoSplit(side, this.parent);
      TabbedView.allTabbedViews[this.path] = this;
      if (TabbedView.allTabbedViews.length > 10) {
        consol.log("DEBUG: My, there are a lot of TabbedViews.  Is delete() being called?");
      }
      this.lastid = 0;
      return this.compileComponent("TabbedView", {
        path: this.path,
        tabbedview: this
      }, this.blade).then((function(_this) {
        return function(html) {
          var containerEl;
          _this.tabbedviewEl = $(html);
          containerEl = Utils.$one("#" + _this.path);
          containerEl.append(_this.tabbedviewEl);
          _this.addEventListeners();
          _this.tabContainer = $(".nav-tabs", containerEl);
          _this.paneContainer = $("[data-tabbedview-panes]", containerEl);
          return _this.initSortable();
        };
      })(this)).then((function(_this) {
        return function() {
          return _this;
        };
      })(this));
    };


    /*
    Adds event listeners.
     */

    TabbedView.prototype.addEventListeners = function() {
      var mergeEl, splitHorizontalEl, splitVerticalEl;
      splitHorizontalEl = Utils.$one("[data-split-horizontal-menu-item]", this.tabbedviewEl);
      splitHorizontalEl.mouseover((function(_this) {
        return function() {
          return _this.preview("horizontal");
        };
      })(this));
      splitHorizontalEl.mouseout((function(_this) {
        return function() {
          return _this.unpreview("horizontal");
        };
      })(this));
      splitHorizontalEl.click((function(_this) {
        return function(e) {
          e.preventDefault();
          return _this.divide("horizontal");
        };
      })(this));
      splitVerticalEl = Utils.$one("[data-split-vertical-menu-item]", this.tabbedviewEl);
      splitVerticalEl.mouseover((function(_this) {
        return function() {
          return _this.preview("vertical");
        };
      })(this));
      splitVerticalEl.mouseout((function(_this) {
        return function() {
          return _this.unpreview("vertical");
        };
      })(this));
      splitVerticalEl.click((function(_this) {
        return function(e) {
          e.preventDefault();
          return _this.divide("vertical");
        };
      })(this));
      mergeEl = $("[data-merge-menu-item]", this.tabbedviewEl);
      mergeEl.mouseover((function(_this) {
        return function() {
          return _this.mergePreview();
        };
      })(this));
      mergeEl.mouseout((function(_this) {
        return function() {
          return _this.mergeUnpreview();
        };
      })(this));
      return mergeEl.click((function(_this) {
        return function(e) {
          e.preventDefault();
          return _this.close();
        };
      })(this));
    };


    /*
    Resize event listener.
    Resize the visible pane.
     */

    TabbedView.prototype.resize = function() {
      if (this.activePane) {
        return this.activePane.resize();
      }
    };


    /*
    Delete this tab
     */

    TabbedView.prototype["delete"] = function() {
      return delete TabbedView.allTabbedViews[this.path];
    };


    /*
    Set splitSide and containingSplit.
    TODO: Make a Mixin for FlexSplitPanel.  splitSide <=> parentKey, containingSplit <=> parent
     */

    TabbedView.prototype.intoSplit = function(splitSide, containingSplit) {
      this.splitSide = splitSide;
      this.containingSplit = containingSplit;
      return this;
    };


    /*
    Calls preview method of the parent {FlexSplit} for this {TabbedView}'s side.
    @param {"vertical", "horizontal"} direction the direction to create the subsplit
     */

    TabbedView.prototype.preview = function(direction) {
      return this.containingSplit.preview(this.splitSide, direction);
    };


    /*
    Calls unpreview method of the parent {FlexSplit} for this {TabbedView}'s side.
    @param {"vertical", "horizontal"} direction the direction to create the subsplit
     */

    TabbedView.prototype.unpreview = function(direction) {
      return this.containingSplit.unpreview(this.splitSide, direction);
    };

    TabbedView.prototype.mergePreview = function() {
      return this.containingSplit.mergePreview();
    };

    TabbedView.prototype.mergeUnpreview = function() {
      return this.containingSplit.mergeUnpreview();
    };


    /*
    Calls divide method of the parent {FlexSplit} for this {TabbedView}'s side.
    @param {"vertical", "horizontal"} direction the direction to create the subsplit
    @return {Promise<Array<TabbedView>>} the two newly created `TabbedView`s that were inserted.
     */

    TabbedView.prototype.divide = function(direction) {
      return this.containingSplit.divide(this.splitSide, direction, this);
    };

    TabbedView.prototype.close = function() {
      return this.containingSplit.close(this.splitSide);
    };


    /*
    Adds a tab/pane to this {TabbedView}.
    @param {Pane} pane The pane to add to the page
    @return {Promise<Pane>}
     */

    TabbedView.prototype.append = function(pane) {
      this.addPane(pane);
      this.tabContainer.append(pane.tabEl);
      if (pane.active) {
        return pane.resize();
      }
    };


    /*
    Add a {Pane} to this {TabbedView}.  Does not add the tab.  Adds the {Pane} to the DOM
    if pane.alwaysInDOM.  Does not activate the pane.
    @param {Pane} pane the {Pane} to add.
     */

    TabbedView.prototype.addPane = function(pane) {
      if (this.panes[pane.seqID]) {
        console.log("Adding a pane to TabbedView whose ID already exists.");
      }
      this.panes[pane.seqID] = pane;
      pane.tabbedview = this;
      if (pane.alwaysInDOM) {
        return this.paneContainer.append(pane.paneEl);
      }
    };


    /*
    Return an array of panes in this {TabbedView} ordered by position.
    @return {Array<Panes>} the panes
     */

    TabbedView.prototype.tabOrderedPanes = function() {
      var id, pane, ref2, ret;
      ret = [];
      ref2 = this.panes;
      for (id in ref2) {
        pane = ref2[id];
        ret[pane.getTabPosition()] = pane;
      }
      return ret;
    };


    /*
    @return {int} count of the number of tabs in this {TabbedView}
     */

    TabbedView.prototype.getTabCnt = function() {
      return tabContainer.children().length;
    };


    /*
    Get corresponding {Pane} of a tab DOM node (for processing events on the tab).
    @param [Node] DOM node of the tab
    @return {Pane} the pane
     */

    TabbedView.prototype.getPaneOfTabEl = function(el) {
      return TabbedView.allPanes[$(el).attr("data-tabbedview-ref")];
    };


    /*
    @param [Node] DOM node of the tab
    @return {TabbedView} the tabbed view the tab is in (based on DOM)
     */

    TabbedView.prototype.getTabbedViewOfTabEl = function(el) {
      var ret;
      ret = TabbedView.allTabbedViews[$(el).parents("[data-TabbedView]").parent().attr("id")];
      if (!ret) {
        console.log("getTabbedViewOfTabEl failed");
      }
      return ret;
    };


    /*
    Ensures that tabs are ready to be sorted and moved between tab bars, with all listeners in place.
    TODO: Hopefully this is only called once now.  Can delete the cleanup steps?
     */

    TabbedView.prototype.initSortable = function() {

      /*
      Adds a dummy div.nav.nav-tabs to the body (if it doesn't already exist) to display mid-drag tabs in.
       */
      if ($("body > .nav").length < 1) {
        $("body").append($("<div>").addClass("nav nav-tabs"));
      }

      /*
      Remove old sortable bindings to ensure we don't duplicate them.
       */
      if (this.tabContainer.hasClass("sortable")) {
        this.tabContainer.sortable("destroy").removeClass("sortable").off("sortremove").off("SortMoveElement").off("sortstop");
      }

      /*
      Add sortable binding for tabs, so they can be rearranged or dropped into other tab holders.
       */
      this.tabContainer.sortable({
        connectWith: "[data-TabbedView-tabs] .nav",
        scroll: false,
        appendTo: "body > .nav",
        helper: "clone",
        placeholder: "TabbedView-sortable-placeholder"
      }).addClass("sortable");

      /*
      `sortstart` triggered by the sorting library when one of our tabs starts to move.
      ##
      @tabContainer
        .on "sortstart", (event, ui) =>
          console.log "sortstart"
       */

      /*
      `sortremove` triggered by the sorting library when one of our tabs moves.
      Check to see if it is moving out of our tab group, and inform all tab groups that it's moving.
      ##
      @tabContainer
        .on "sortremove", (event, ui) =>
          return
       */

      /*
      `sortstop` triggered by the sorting library when a tab that was in this {TabbedView} is moved.
       */
      return this.tabContainer.on("sortstop", (function(_this) {
        return function(event, ui) {
          var destTabbed, item, pane, tabEl;
          item = ui.item;
          tabEl = item[0];
          pane = _this.getPaneOfTabEl(tabEl);
          Utils.assert(_this === pane.tabbedview, "\"sortstop\" triggered on TabbedView for tab it doesn't contain.");
          destTabbed = _this.getTabbedViewOfTabEl(tabEl);
          if (destTabbed !== _this) {
            _this.dissociate(pane);
            destTabbed.addPane(pane);
            return destTabbed.activatePane(pane);
          } else {
            if (!pane.active) {
              return _this.activatePane(pane);
            }
          }
        };
      })(this));
    };


    /*
    Dissociate a given {Pane} from this {TabbedView}.
    Active a new tab if necessary, and
    delete the given pane from @panes.
    This method does not remove tab/pane from the DOM.
    @param {Pane} pane The {Pane} to dissociate.
     */

    TabbedView.prototype.dissociate = function(pane) {

      /*
      If this pane is active, activate the first pane
      in panes that isnt 'pane' (or no pane).  (This will deactivate 'pane'.)
       */
      var id, newPane, p, ref2;
      if (pane === this.activePane) {
        newPane = null;
        ref2 = this.panes;
        for (id in ref2) {
          p = ref2[id];
          if (p !== pane) {
            newPane = p;
            break;
          }
        }
        this.activatePane(newPane);
      }
      Utils.assert(this.panes[pane.seqID], "Removing a pane " + pane.mnemonic + " from TabbedView it isn't in.");
      return delete this.panes[pane.seqID];
    };


    /*
    Gets the position of a tab relative to other tabs.
    @param {jQuery} item a tab
    @return {int} the index of the given tab
     */

    TabbedView.prototype.getPosition = function(item) {
      return item.parent().children().index(item);
    };


    /*
    Returns the largest position of any tab in the given array of tabs.
    @return {int} the largest position
     */

    TabbedView.prototype.maxPosition = function(tabs) {
      var k, position;
      return Math.max.apply(Math, [-1].concat(slice.call((function() {
        var results;
        results = [];
        for (k in tabs) {
          if (!hasProp.call(tabs, k)) continue;
          position = tabs[k].position;
          results.push(position);
        }
        return results;
      })())));
    };


    /*
    Sorts the tabs object into an array of keys ordered by their position
    @return {Array<int>} the keys ordered by the position of the tab they represent.
     */

    TabbedView.prototype.sortPosition = function(tabs) {
      return Object.keys(tabs).sort(function(a, b) {
        return tabs[a].position - tabs[b].position;
      });
    };


    /*
    Activate the given pane.
     */

    TabbedView.prototype.activatePane = function(pane) {
      var id, p, ref2;
      if (pane !== this.activePane) {
        ref2 = this.panes;
        for (id in ref2) {
          p = ref2[id];
          p.setTabActive(p === pane);
        }
        if (this.activePane) {
          if (this.activePane.alwaysInDOM) {
            this.activePane.paneEl.attr("data-tabbedview-active", "false");
          } else {
            this.activePane.paneEl.detach();
          }
        }
        if (pane) {
          if (!pane.alwaysInDOM) {
            this.paneContainer.append(pane.paneEl);
          }
          pane.resize();
          pane.paneEl.attr("data-tabbedview-active", "true");
        }
        return this.activePane = pane;
      }
    };

    return TabbedView;

  })();

  define("TabbedView", function(require, exports, module) {
    BladeComponent = require("BladeComponent");
    FlexSplit = require("FlexSplit");
    Promise = require("bluebird");
    $ = require("jquery");
    Utils = require("Utils");
    Logging = require("Logging");
    require("jquery.ui");
    TabbedView.prototype = $.extend({}, BladeComponent, FlexSplit.Child, module.config(), TabbedView.prototype);
    return TabbedView;
  });

}).call(this);
