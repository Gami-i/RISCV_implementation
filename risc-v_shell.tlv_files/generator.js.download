(function() {
  var $, SignalValue, Utils, Variable, WaveformGenerator, appendHexChunk, isNumber, ref, valToBin, valToHex, valToHexChunks, valToHexRemainder,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    hasProp = {}.hasOwnProperty;

  ref = [], $ = ref[0], SignalValue = ref[1], Variable = ref[2], Utils = ref[3];


  /*
  object for creating and updating <svg> elements representing the waveform in the given waveData object
   */

  WaveformGenerator = (function() {
    WaveformGenerator.prototype.pane = null;

    WaveformGenerator.prototype.path = "";

    WaveformGenerator.prototype.windowWidth = 0;

    WaveformGenerator.prototype.waveRegion = 0;

    WaveformGenerator.prototype.ELEMENT_HEIGHT = 20;

    WaveformGenerator.prototype.CHARACTER_WIDTH = 8;

    WaveformGenerator.prototype.VALUE_REGION_WIDTH = 30;

    WaveformGenerator.prototype.CHARS_IN_VALUE_REGION = 3;

    WaveformGenerator.prototype.isChrome = false;

    WaveformGenerator.prototype.isFirefox = false;

    WaveformGenerator.prototype.radix = "hex";

    WaveformGenerator.prototype.currentStart = 0;

    WaveformGenerator.prototype.currentEnd = 0;

    WaveformGenerator.prototype.textRegionWidth = 0;

    WaveformGenerator.prototype.cyclesPerPixel = 0;

    WaveformGenerator.prototype.svgHeight = 0;

    WaveformGenerator.prototype.loading = false;

    WaveformGenerator.prototype.waveData = null;

    WaveformGenerator.prototype.timescale = null;

    WaveformGenerator.prototype.svg = "";

    WaveformGenerator.prototype.lineCycle = 0;

    WaveformGenerator.prototype.currentSigs = null;

    WaveformGenerator.prototype.numVisible = 0;


    /*
    constructs a new WaveformGenerator object
    @param {WaveformViewer} pane, the containing {WaveformViewer} pane.
    @param {Object} waveData the waveData object that stores the relevant waveData object
    @param {String} path the html path to this element
     */

    function WaveformGenerator(pane, waveData, path) {
      this.pane = pane;
      this.path = path;
      this.drawBusSignal = bind(this.drawBusSignal, this);
      this.drawBitSignal = bind(this.drawBitSignal, this);
      this.isChrome = navigator.userAgent.search("Chrome") > -1;
      this.isFirefox = navigator.userAgent.search("Firefox") > -1;
      this.currentStart = waveData.getStartCycle();
      this.currentEnd = waveData.getEndViewerCycle();
      this.textRegionWidth = 0;
      this.cyclesPerPixel = 0;
      this.svgHeight = 0;
      this.waveData = waveData;
      this.timescale = {
        number: 1,
        unit: "whocares"
      };
      this.initializeCurrentSigs();
      this.numVisible = 0;
    }

    WaveformGenerator.prototype.setCursorEl = function(cursorElName, cyc) {
      var lineHeight, position;
      position = Math.round((cyc - this.currentStart) / this.cyclesPerPixel + this.textRegionWidth);
      lineHeight = this.svgHeight;
      $("." + cursorElName).html("<line x1=\"" + position + "\" y1=\"0\" x2=\"" + position + "\" y2=\"" + lineHeight + "\"></line>");
      return $("." + cursorElName + "Ruler").html('<line x1="' + ("" + position) + '" y1="0" x2="' + ("" + position) + '" y2="20"></line>');
    };


    /*
    Moves the cursor on the waveform to the given cycle
    @param {Number} cyc the (phase-granular) cycle to which to move the cursor
     */

    WaveformGenerator.prototype.setLineByCycle = function(cyc) {
      var el, hex, i, key, ref1, ref2, v, valid, value;
      if (cyc < this.currentStart || cyc > this.currentEnd) {
        $(".verticalLine").html("");
        $(".verticalLineRuler").html("");
      } else {
        this.setCursorEl("verticalLine", cyc);
      }
      i = 0;
      ref1 = this.currentSigs;
      for (key in ref1) {
        if (!hasProp.call(ref1, key)) continue;
        value = ref1[key];
        if (!value.visible) {
          continue;
        }
        if (value.type === "wire") {
          ref2 = this.waveData.getSignalByName(key).getValueAndValidAtCycle(cyc), v = ref2[0], valid = ref2[1];
          Utils.assert(typeof v === "string", "Waveform viewer bug. Looked up nonexistent signal value");
          if (v !== null) {
            hex = valToHex(v);
            el = $("#value_" + i);
            el.attr("mc-valid", "" + valid);
            el.html("<title>" + hex + "</title>" + (this.shortenText(hex, this.CHARS_IN_VALUE_REGION * this.CHARACTER_WIDTH)));
          }
        }
        i++;
      }
      return this.lineCycle = cyc;
    };


    /*
    Set the viz cursor to the given cycle.
    @param {Number} cyc the cycle to which to move the cursor
     */

    WaveformGenerator.prototype.setVizCursorCycle = function(cyc) {
      if (cyc === null || cyc < this.currentStart || cyc > this.currentEnd) {
        $(".vizCursor").html("");
        return $(".vizCursorRuler").html("");
      } else {
        return this.setCursorEl("vizCursor", cyc);
      }
    };


    /*
    Moves the vertical line to the given signal's next transition after the given cycle
    [Unused]
    @param {String} signal the signal to snap to
    @param {Number} cyc the minimum cycle of the transition
     */

    WaveformGenerator.prototype.setLineBySignalCycle = function(signal, cyc) {
      var s, sv;
      s = this.waveData.getSignalByName(signal);
      sv = new SignalValue(s, cyc);
      return this.setLineByCycle(sv.getTransitionCycle());
    };


    /*
    Moves the vertical line to the position on the page
    @param {Number} pos the position to move to
     */

    WaveformGenerator.prototype.setLineByPosition = function(pos) {
      return this.setLineByCycle(Math.round((pos - this.textRegionWidth) * this.cyclesPerPixel + this.currentStart));
    };


    /*
    Zoom in on the waveform by a factor of 2.
    If the marker is in view, zoom around the marker, otherwise
    zoom around the center.
     */

    WaveformGenerator.prototype.zoomIn = function() {
      var focalCyc, ref1;
      focalCyc = (this.lineCycle != null) && ((this.currentStart <= (ref1 = this.lineCycle) && ref1 <= this.currentEnd)) ? this.lineCycle : (this.currentStart + this.currentEnd) / 2;
      return this.generateWave((this.currentStart + focalCyc) / 2, (focalCyc + this.currentEnd) / 2);
    };


    /*
    Zooms out on the waveform by a factor of 2, or to the full waveform, whichever is smaller.
     */

    WaveformGenerator.prototype.zoomOut = function() {
      var f, half, maxEnd, maxStart, newEnd, newStart, newWidth, width;
      width = this.currentEnd - this.currentStart;
      maxStart = this.waveData.getStartCycle();
      maxEnd = this.waveData.getEndViewerCycle();
      newWidth = 2 * width;
      if (newWidth >= maxEnd - maxStart) {
        return this.generateWave();
      } else {
        half = width / 2;
        newStart = this.currentStart - half;
        if (newStart < maxStart) {
          newStart = maxStart;
        }
        f = newEnd = this.currentEnd + half;
        if (newEnd > maxEnd) {
          newEnd = maxEnd;
          newStart = newEnd - newWidth;
        }
        return this.generateWave(newStart, newEnd);
      }
    };


    /*
    zooms out to see the entire waveform
     */

    WaveformGenerator.prototype.zoomFull = function() {
      return this.generateWave();
    };


    /*
    moves left on the waveform view if possible
     */

    WaveformGenerator.prototype.moveLeft = function() {
      var maxStart, newStart, quarter, width;
      width = this.currentEnd - this.currentStart;
      maxStart = this.waveData.getStartCycle();
      quarter = Math.ceil(width / 4);
      newStart = this.currentStart - quarter;
      if (newStart < maxStart) {
        newStart = maxStart;
      }
      return this.generateWave(newStart, newStart + width);
    };


    /*
    moves right on the waveform view if possible
     */

    WaveformGenerator.prototype.moveRight = function() {
      var end, maxEnd, quarter, width;
      width = this.currentEnd - this.currentStart;
      maxEnd = this.waveData.getEndViewerCycle();
      quarter = Math.ceil(width / 4);
      end = this.currentEnd + quarter;
      if (end > maxEnd) {
        end = maxEnd;
      }
      return this.generateWave(end - width, end);
    };


    /*
    Initializes the current signals in the waveform
    (currently all signals as given by vcd, but paves way for trimming, rearranging shown signals)
     */

    WaveformGenerator.prototype.initializeCurrentSigs = function() {
      var lastScope, name, obj, ports, results, sig, sigs;
      this.currentSigs = {};
      sigs = this.waveData.getSignals();
      lastScope = "";
      results = [];
      for (name in sigs) {
        if (!hasProp.call(sigs, name)) continue;
        sig = sigs[name];
        if (sig.scope !== lastScope) {
          this.addScopeLines(lastScope, sig.scope);
          lastScope = sig.scope;
        }
        ports = sig.ports != null ? sig.ports : "";
        obj = {
          signal: sig,
          scope: sig.scope,
          name: sig.fullName + ports,
          notFullName: sig.notFullName,
          ports: ports,
          visible: true,
          type: sig.type,
          width: sig.width,
          data: sig.data,
          svg: "",
          cycle: sig.cycle
        };
        results.push(this.currentSigs[name] = obj);
      }
      return results;
    };


    /*
    A helper method to split a properly-formed scope string of either SV scope delimited by '.' or
    TLV scope containing behavioral hierarchy and pipeline scopes into an array.
    @param {String} scopeStr the scope string.
    @return {Array<String>} Array of scopes ([0] is outermost, inclusive of scope prefix and '.')
     */

    WaveformGenerator.prototype.splitScopes = function(scopeStr) {
      var i, j, ref1, ref2, ret, splitPos;
      if (scopeStr === "") {
        return "";
      }
      ret = [];
      splitPos = 0;
      for (i = j = 1, ref1 = scopeStr.length; 1 <= ref1 ? j < ref1 : j > ref1; i = 1 <= ref1 ? ++j : --j) {
        if ((ref2 = scopeStr[i]) === ">" || ref2 === "/" || ref2 === "|" || ref2 === ".") {
          ret.push(scopeStr.substring(splitPos, i));
          splitPos = i;
        }
      }
      ret.push(scopeStr.substring(splitPos));
      return ret;
    };


    /*
    Adds the blank scope lines with indentation to the waveform
    @param {String} lastScope the last scope seen in the trace
    @param {String} currentScope the current scope being added
     */

    WaveformGenerator.prototype.addScopeLines = function(lastScope, currentScope) {
      var currentScopePos, currentScopes, i, j, l, lastScopes, li, ref1, ref2, results, s, scope, x;
      lastScopes = this.splitScopes(lastScope);
      currentScopes = this.splitScopes(currentScope);
      currentScopePos = 0;
      results = [];
      for (i = j = 0, ref1 = currentScopes.length; 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
        s = currentScopes[i];
        currentScopePos += s.length;
        if (s[0] === ".") {
          s = s.substring(1);
        }
        if (s !== lastScopes[i]) {
          scope = currentScope.substring(0, currentScopePos);
          for (x = l = 0, ref2 = i; 0 <= ref2 ? l < ref2 : l > ref2; x = 0 <= ref2 ? ++l : --l) {
            s = "  " + s;
          }
          li = scope;
          if (li.startsWith(Variable.tlvTopScopeName) && (li.length > Variable.tlvTopScopeName.length)) {
            li = li.substring(Variable.tlvTopScopeName.length);
          }
          results.push(this.currentSigs[li] = {
            scope: scope,
            name: s,
            li: li,
            type: "SCOPE",
            visible: true,
            expanded: true
          });
        } else {
          results.push(void 0);
        }
      }
      return results;
    };


    /*
    Expands a scope to display all of its signals and nested scopes, without re-rendering.
    Currently more of a hack that keeps display hierarchy in an array rather than a proper hierarchy
    @TODO refactor with classes and actual hierarchy
    @param {String} li the logical instance of the scope to expand
     */

    WaveformGenerator.prototype.expandScope = function(li) {
      var currentScope, inScope, j, name, ogScope, outOfScope, overHidden, ref1, ref2, ref3, results, signal, visArr, x;
      inScope = false;
      ogScope = [];
      currentScope = [];
      visArr = [];
      overHidden = false;
      ref1 = this.currentSigs;
      results = [];
      for (name in ref1) {
        if (!hasProp.call(ref1, name)) continue;
        signal = ref1[name];
        if (signal.type === "SCOPE") {
          if (outOfScope = inScope && signal.visible) {
            break;
          }
          if (!inScope && signal.li === li) {
            inScope = true;
            signal.expanded = true;
            ogScope = currentScope = signal.scope.split(/[\/|>\.]/g);
            for (x = j = 0, ref2 = ogScope.length; 0 <= ref2 ? j < ref2 : j > ref2; x = 0 <= ref2 ? ++j : --j) {
              visArr.push(true);
            }
            continue;
          }
          if (inScope) {
            results.push((ref3 = this.helpExpandScope(signal, overHidden, visArr, currentScope), overHidden = ref3[0], visArr = ref3[1], currentScope = ref3[2], ref3));
          } else {
            results.push(void 0);
          }
        } else if (inScope && !overHidden) {
          results.push(signal.visible = true);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };


    /*
    Helper method for expandScope, processes a single scope that is nested in the scope being expanded
    @param {Object} signal the scope signal being processed
    @param {Boolean} overHidden whether this scope is being hidden by a parent scope
    @param {Array<Boolean>} visArr a boolean array representing expanded and collapsed parent scopes
    @param {Array<String>} currentScope an array of strings representing this scope's hierarchy
    @return {[Boolean, Array<Boolean>, Array<String>]} returns updated `overHidden`, `visArr`, and `currentScope`
     */

    WaveformGenerator.prototype.helpExpandScope = function(signal, overHidden, visArr, currentScope) {
      var i, j, last, ref1, tempScope;
      tempScope = signal.scope.split(/[\/|>\.]/g);
      last = 0;
      for (i = j = 0, ref1 = Math.min(tempScope.length, currentScope.length); 0 <= ref1 ? j < ref1 : j > ref1; i = 0 <= ref1 ? ++j : --j) {
        if (tempScope[i] === currentScope[i]) {
          last = i;
        }
      }
      visArr = visArr.slice(0, +last + 1 || 9e9);
      if (visArr[visArr.length - 1]) {
        overHidden = !signal.expanded;
        signal.visible = true;
        visArr.push(signal.expanded);
      } else {
        overHidden = true;
      }
      currentScope = tempScope;
      return [overHidden, visArr, currentScope];
    };


    /*
    Expands all scopes such that all signals within them will be shown.
    @return {Boolean} true if any changes were made requiring @generateWaves(...)
     */

    WaveformGenerator.prototype.expandAllScopes = function() {
      var name, ref1, signal;
      ref1 = this.currentSigs;
      for (name in ref1) {
        if (!hasProp.call(ref1, name)) continue;
        signal = ref1[name];
        if (signal.type === "SCOPE") {
          signal.expanded = true;
        }
        signal.visible = true;
      }
      return true;
    };


    /*
    Collapses all scopes to only top scope, without re-rendering.
    @return {Boolean} true if any changes were made requiring @generateWaves(...)
     */

    WaveformGenerator.prototype.collapseAllScopes = function() {
      var index, name, ref1, signal;
      index = 0;
      ref1 = this.currentSigs;
      for (name in ref1) {
        if (!hasProp.call(ref1, name)) continue;
        signal = ref1[name];
        if (signal.type === "SCOPE") {
          signal.expanded = false;
          signal.visible = signal.name === signal.scope;
        } else {
          signal.visible = signal.scope === "";
        }
        index++;
      }
      return true;
    };


    /*
    Collapses a scope so its signals and nested scopes are not displayed, without re-rendering.
    @TODO refactor with classes and actual hierarchy
    @param {String} li the logical instance of the scope to collapse
     */

    WaveformGenerator.prototype.collapseScope = function(li) {
      var fullScope, inScope, name, ref1, results, signal, word_char_re;
      inScope = false;
      fullScope = "";
      word_char_re = /^[a-zA-Z0-9_]$/;
      ref1 = this.currentSigs;
      results = [];
      for (name in ref1) {
        if (!hasProp.call(ref1, name)) continue;
        signal = ref1[name];
        if (signal.type === "SCOPE") {
          if (signal.li === li) {
            fullScope = signal.scope;
            inScope = true;
            signal.expanded = false;
            continue;
          }

          /*
          if the new scope doesn't start with the entire original scope (or continues with a word char),
          then we have exited the collapsing scope and should stop
           */
          if (inScope) {
            if ((signal.scope.indexOf(fullScope) !== 0) || (word_char_re.test(signal.scope.charAt(fullScope.length)))) {
              inScope = false;
              break;
            } else {
              signal.expanded = false;
            }
          }
        }
        if (inScope) {
          results.push(signal.visible = false);
        } else {
          results.push(void 0);
        }
      }
      return results;
    };


    /*
    main method for generating the actual <svg> for the waveform. has two optional start and end options
    TODO: Don't regenerate buttons and defs every time.
    @param {Number} start optional argument giving start cycle
    @param {Number} end optional argument giving end cycle
    @param {Number} windowWidth **OPTIONAL** New width at which to generate.
    @return {String} the string representation of the svg output
     */

    WaveformGenerator.prototype.generateWave = function(start, end, windowWidth) {
      var html, len, n, nameLen, newEnd, newStart, pixelsPerCycle, ref1, textRegion, v, width;
      if (windowWidth) {
        this.windowWidth = windowWidth;
      }
      html = "";
      this.currentStart = newStart = start != null ? start : this.waveData.getStartCycle();
      this.currentEnd = newEnd = end != null ? end : this.waveData.getEndViewerCycle();
      width = newEnd - newStart;
      nameLen = 10;
      ref1 = this.currentSigs;
      for (n in ref1) {
        v = ref1[n];
        if (v.type === "wire") {
          len = v.notFullName.length;
          if (len > nameLen) {
            nameLen = len;
          }
        }
      }
      if (nameLen > 35) {
        nameLen = 35;
      }
      textRegion = nameLen * 8;
      textRegion = Math.min(textRegion, this.windowWidth / 3);
      this.textRegionWidth = textRegion + this.VALUE_REGION_WIDTH;
      this.waveRegion = this.windowWidth - this.textRegionWidth;
      if (this.waveRegion < 0) {
        this.waveRegion = 0;
      }
      pixelsPerCycle = this.waveRegion / width;
      this.cyclesPerPixel = width / this.waveRegion;
      this.numVisible = this.getNumVisible();
      this.svgHeight = this.ELEMENT_HEIGHT * this.numVisible;
      html += "<!-- Begin Ruler -->\n<div data-WaveformViewer-ruler=\"data-WaveformViewer-ruler\"><svg\n    xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\"\n    id=\"" + this.path + "-svg-ruler\" width=\"" + this.windowWidth + "\" height=\"" + this.ELEMENT_HEIGHT + "\">\n  <defs>\n    <g id=\"b\"><rect width=\"1\" height=\"" + this.ELEMENT_HEIGHT + "\" style=\"fill:rgb(0,0,0);stroke-width:0\"></rect></g>\n    <g id=\"gray\"><rect width=\"1\" height=\"" + this.ELEMENT_HEIGHT + "\" style=\"fill:dimGray;stroke-width:0\"></rect></g>\n    <g id=\"majorMark\"><line x1=\"0\" y1=\"18\" x2=\"0\" y2=\"0\" style=\"stroke:honeydew; stroke-width:1\"/></g>\n    <g id=\"minorMark\"><line x1=\"0\" y1=\"18\" x2=\"0\" y2=\"12\" style=\"stroke:honeydew; stroke-width:1\"/></g>\n    <g id=\"rulerLine\"><line x1=\"0\" y1=\"18\" x2=\"1\" y2=\"18\" style=\"stroke:honeydew; stroke-width:1\"/></g>\n  </defs>";
      if (this.waveRegion > 0) {
        html += this.createRuler(pixelsPerCycle);
      }
      html += "  <g class=\"verticalLineRuler\" style=\"display:block; stroke-width:1\" transform=\"translate(0,0)\"></g>\n  <g class=\"vizCursorRuler\" style=\"display:block; stroke-width:1\" transform=\"translate(0,0)\"></g>\n</svg></div>\n<div id=\"" + this.path + "-waveform-body-wrapper\", data-WaveformViewer-body-wrapper=\"data-WaveformViewer-body-wrapper\">\n<svg\n  xmlns=\"http://www.w3.org/2000/svg\" xmlns:xlink=\"http://www.w3.org/1999/xlink\" version=\"1.1\"\n  width=\"" + this.windowWidth + "\" height=\"" + this.svgHeight + "\">\n<defs>\n  <g id=\"b\"><rect width=\"1\" height=\"" + this.ELEMENT_HEIGHT + "\" style=\"fill:rgb(0,0,0);stroke-width:0\"></rect></g>\n  <g id=\"gray\"><rect width=\"1\" height=\"" + this.ELEMENT_HEIGHT + "\" style=\"fill:dimGray;stroke-width:0\"></rect></g>\n  <g id=\"zero\"><line x1=\"0\" y1=\"18\" x2=\"1\" y2=\"18\" style=\"stroke:turquoise; stroke-width:1\"/></g>\n  <g id=\"one\"><line x1=\"0\" y1=\"2\" x2=\"1\" y2=\"2\" style=\"stroke:lime; stroke-width:2\"/></g>\n  <g id=\"z\"><line x1=\"0\" y1=\"10\" x2=\"1\" y2=\"10\" style=\"stroke:Peru; stroke-width:1\"/></g>\n  <g id=\"x\">\n    <rect y=\"2\" width=\"1\" height=\"16\" style=\"fill:crimson;stroke-width:0; opacity:0.5\"/>\n      <line x1=\"0\" y1=\"2\" x2=\"1\" y2=\"2\" style=\"stroke:crimson; stroke-width:1\"/>\n      <line x1=\"0\" y1=\"18\" x2=\"1\" y2=\"18\" style=\"stroke:crimson; stroke-width:1\"/>\n    </rect>\n  </g>\n  <g id=\"BlurValidBus\"><rect x=\"0\" y=\"2\" width=\"1\" height=\"18.02\" style=\"fill:bisque\"/></g>\n  <g id=\"BlurValidBit\"><rect x=\"0\" y=\"2\" width=\"1\" height=\"18.02\" style=\"fill:turquoise\"/></g>\n  <g id=\"BlurUnkValidity\"><rect x=\"0\" y=\"2\" width=\"1\" height=\"18.02\" style=\"fill:crimson\"/></g>\n  <g id=\"BlurInvalid\"><rect x=\"0\" y=\"2\" width=\"1\" height=\"18.02\" style=\"fill:gray\"/></g>\n  <g id=\"xEdge\"><line x1=\"0\" y1=\"18\" x2=\"0\" y2=\"2\" style=\"stroke:crimson; stroke-width:1\"/></g>\n  <g id=\"risingEdge\"><line x1=\"0\" y1=\"18\" x2=\"0\" y2=\"2\" style=\"stroke:lime; stroke-width:1\"/></g>\n  <g id=\"zeroToZ\"><line x1=\"0\" y1=\"18\" x2=\"0\" y2=\"10\" style=\"stroke:lime; stroke-width:1\"/></g>\n  <g id=\"ZToOne\"><line x1=\"0\" y1=\"10\" x2=\"0\" y2=\"2\" style=\"stroke:lime; stroke-width:1\"/></g>\n  <g id=\"fallingEdge\"><line x1=\"0\" y1=\"2\" x2=\"0\" y2=\"18\" style=\"stroke:turquoise; stroke-width:1\"/></g>\n  <g id=\"oneToZ\"><line x1=\"0\" y1=\"2\" x2=\"0\" y2=\"10\" style=\"stroke:turquoise; stroke-width:1\"/></g>\n  <g id=\"ZToZero\"><line x1=\"0\" y1=\"10\" x2=\"0\" y2=\"18\" style=\"stroke:turquoise; stroke-width:1\"/></g>\n  <g id=\"bus\">\n    <line x1=\"0\" y1=\"18\" x2=\"1\" y2=\"18\" style=\"stroke:bisque; stroke-width:1\"/>\n    <line x1=\"0\" y1=\"2\" x2=\"1\" y2=\"2\" style=\"stroke:bisque; stroke-width:1\"/>\n  </g>\n  <g id=\"xbus\">\n    <line x1=\"0\" y1=\"18\" x2=\"1\" y2=\"18\" style=\"stroke:crimson; stroke-width:1\"/>\n    <line x1=\"0\" y1=\"2\" x2=\"1\" y2=\"2\" style=\"stroke:crimson; stroke-width:1\"/>\n  </g>\n  <g id=\"busStart\">\n    <line x1=\"0\" y1=\"10\" x2=\"1.5\" y2=\"2\" style=\"stroke:bisque; stroke-width:1\"/>\n    <line x1=\"0\" y1=\"10\" x2=\"1.5\" y2=\"18\" style=\"stroke:bisque; stroke-width:1\"/>\n  </g>\n  <g id=\"xbusStart\">\n    <line x1=\"0\" y1=\"10\" x2=\"1.5\" y2=\"2\" style=\"stroke:crimson; stroke-width:1\"/>\n    <line x1=\"0\" y1=\"10\" x2=\"1.5\" y2=\"18\" style=\"stroke:crimson; stroke-width:1\"/>\n  </g>\n  <g id=\"busEnd\">\n    <line x1=\"0\" y1=\"18\" x2=\"1.5\" y2=\"10\" style=\"stroke:bisque; stroke-width:1\"/>\n    <line x1=\"0\" y1=\"2\" x2=\"1.5\" y2=\"10\" style=\"stroke:bisque; stroke-width:1\"/>\n  </g>\n  <g id=\"xbusEnd\">\n    <line x1=\"0\" y1=\"18\" x2=\"1.5\" y2=\"10\" style=\"stroke:crimson; stroke-width:1\"/>\n    <line x1=\"0\" y1=\"2\" x2=\"1.5\" y2=\"10\" style=\"stroke:crimson; stroke-width:1\"/>\n  </g>\n  <g id=\"busChange\">\n    <line x1=\"0\" y1=\"18\" x2=\"3\" y2=\"2\" style=\"stroke:bisque; stroke-width:1\"/>\n    <line x1=\"0\" y1=\"2\" x2=\"3\" y2=\"18\" style=\"stroke:bisque; stroke-width:1\"/>\n  </g>\n  <g id=\"DCZero\"><line x1=\"0\" y1=\"18\" x2=\"1\" y2=\"18\" style=\"stroke:gray; stroke-width:1\"></line></g>\n  <g id=\"DCOne\"><line x1=\"0\" y1=\"2\" x2=\"1\" y2=\"2\" style=\"stroke:gray;stroke-width:2\"></line></g>\n  <g id=\"UnkDCZero\"><line x1=\"0\" y1=\"18\" x2=\"1\" y2=\"18\" style=\"stroke:crimson; stroke-width:1\"></line></g>\n  <g id=\"UnkDCOne\"><line x1=\"0\" y1=\"2\" x2=\"1\" y2=\"2\" style=\"stroke:crimson;stroke-width:2\"></line></g>\n  <g id=\"DCBitEdge\"><line x1=\"0\" y1=\"2\" x2=\"0\" y2=\"18\" style=\"stroke:gray;stroke-width:1\"></line></g>\n  <g id=\"DCOneToZ\"><line x1=\"0\" y1=\"2\" x2=\"0\" y2=\"10\" style=\"stroke:Peru; stroke-width:1\"></line></g>\n  <g id=\"DCZeroToZ\"><line x1=\"0\" y1=\"18\" x2=\"0\" y2=\"10\" style=\"stroke:Peru; stroke-width:1\"></line></g>\n  <g id=\"ZToDCOne\"><line x1=\"0\" y1=\"10\" x2=\"0\" y2=\"2\" style=\"stroke:gray; stroke-width:1\"></line></g>\n  <g id=\"ZToDCZero\"><line x1=\"0\" y1=\"10\" x2=\"0\" y2=\"18\" style=\"stroke:gray; stroke-width:1\"></line></g>\n  <g id=\"DCBusStart\">\n    <line x1=\"0\" y1=\"10\" x2=\"1.5\" y2=\"2\" style=\"stroke:gray;stroke-width:1\"></line>\n    <line x1=\"0\" y1=\"10\" x2=\"1.5\" y2=\"18\" style=\"stroke:gray;stroke-width:1\"></line>\n  </g>\n  <g id=\"DCBus\">\n    <line x1=\"0\" y1=\"2\" x2=\"1\" y2=\"2\" style=\"stroke:gray;stroke-width:1\"></line>\n    <line x1=\"0\" y1=\"18\" x2=\"1\" y2=\"18\" style=\"stroke:gray;stroke-width:1\"></line>\n  </g>\n  <g id=\"DCBusEnd\">\n    <line x1=\"0\" y1=\"18\" x2=\"1.5\" y2=\"10\" style=\"stroke:gray; stroke-width:1\"></line>\n    <line x1=\"0\" y1=\"2\" x2=\"1.5\" y2=\"10\" style=\"stroke:gray; stroke-width:1\"></line>\n  </g>\n</defs>";
      if (this.waveRegion > 0) {
        html += this.createWaves(textRegion, pixelsPerCycle);
      }
      html += '<g class="verticalLine" style="display:block;" transform="translate(0,0)"></g>';
      html += '<g class="vizCursor" style="display:block;" transform="translate(0,0)"></g>';
      html += "</div></svg>";
      this.svg = html;
      return html;
    };


    /*
    Gets the number of visible signals in the waveform
    @return {Number} the number of visible signals
     */

    WaveformGenerator.prototype.getNumVisible = function() {
      var k, ref1, sum, v;
      sum = 0;
      ref1 = this.currentSigs;
      for (k in ref1) {
        if (!hasProp.call(ref1, k)) continue;
        v = ref1[k];
        if (v.visible) {
          sum++;
        }
      }
      return sum;
    };


    /*
    creates time ruler above waveforms
    @param {Number} pixelsPerCycle pixels per cycle
    @return {String} returns the string representation of the svg ruler
     */

    WaveformGenerator.prototype.createRuler = function(pixelsPerCycle) {
      var end, interval, intervalSpace, next, offset, out, position, roundOffset, roundStart, smallInterval, start, tempStart, tick;
      start = this.currentStart;
      end = this.currentEnd;
      interval = this.getIntervalSize(start, end);
      smallInterval = interval / 10;
      offset = 0;
      out = "";
      out += '<g class="ruler" transform="translate(0,0)">';
      out += '<use xlink:href="#gray" transform="scale(' + this.windowWidth + ',1)"/>';
      out += '<g transform="translate(' + this.textRegionWidth + ',0)">';
      out += '<use xlink:href="#rulerLine" transform="scale(' + this.waveRegion + ',1)"/>';
      if (start % interval === 0) {
        offset = 0;
        out += '<use xlink:href="#majorMark" transform="translate(' + offset + ')"/>';
        out += '<text class="time" x="1" y="12">' + this.addCommas(start * this.timescale.number) + "</text>";
        tempStart = start;
      } else {
        if (start % smallInterval === 0) {
          offset = 0;
          out += '<use xlink:href="#minorMark" transform="translate(' + offset + ')"/>';
          tempStart = start;
        } else {
          roundStart = smallInterval * Math.ceil(start / smallInterval);
          offset = pixelsPerCycle * (roundStart - start);
          roundOffset = Math.round(offset.toFixed(2));
          if (roundStart % interval === 0) {
            out += "<use xlink:href=\"#majorMark\" transform=\"translate(" + roundOffset + ")\" />";
            if (next <= end) {
              out += "<text class=\"time\" x=\"1\" y=\"12\" transform=\"translate(" + roundOffset + ")\">\n  " + (this.addCommas(roundStart * this.timescale.number)) + "\n</text>";
            }
          } else {
            out += '<use xlink:href="#minorMark" transform="translate(' + roundOffset + ')"/>';
          }
          tempStart = roundStart;
        }
      }
      roundStart = tempStart + smallInterval;
      intervalSpace = pixelsPerCycle * smallInterval;
      while (true) {
        tick = offset + intervalSpace;
        position = Math.round(tick.toFixed(2));
        next = roundStart + smallInterval;
        if (roundStart % interval === 0) {
          out += '<use xlink:href="#majorMark" transform="translate(' + position + ')"/>';
          if (next <= end) {
            out += "<text class=\"time\" x=\"1\" y=\"12\" transform=\"translate(" + position + ")\">\n  " + (this.addCommas(roundStart * this.timescale.number)) + "\n</text>";
          }
        } else {
          out += '<use xlink:href="#minorMark" transform="translate(' + position + ')"/>';
        }
        offset = tick;
        roundStart = next;
        if (!(roundStart <= end)) {
          break;
        }
      }
      return out + "</g></g>";
    };


    /*
    creates the remainder of the svg containing both the names and the waveforms
    @param {Number} textRegion the width of the name portion of the row
    @param {Number} pixelsPerCycle pixels per cycle
    @param {String} returns the string representation of the wave portion of the svg
     */

    WaveformGenerator.prototype.createWaves = function(textRegion, pixelsPerCycle) {
      var count, expand, fullName, index, key, le, li, name, out, ref1, sign, sv, tempName, wave;
      out = "";
      count = 0;
      ref1 = this.currentSigs;
      for (key in ref1) {
        if (!hasProp.call(ref1, key)) continue;
        wave = this.currentSigs[key];
        if (!wave.visible) {
          continue;
        }
        name = wave.name;
        if (wave.type === "SCOPE") {
          le = wave.li;
          li = wave.li;
          if (wave.scope.startsWith(Variable.tlvTopScopeName) && (wave.scope.length > Variable.tlvTopScopeName.length)) {
            tempName = wave.scope;
            li = tempName.substring(Variable.tlvTopScopeName.length);
            le = li.replace(/\[[0-9]+\]/g, "");
          }
          out += "<g transform=\"translate(0, " + (count * this.ELEMENT_HEIGHT) + ")\" logical_entity=\"" + le + "\" logical_instance=\"" + li + "\">\n  <rect\n    class=\"value scope\" width=\"" + (this.textRegionWidth - textRegion) + "\" height=\"" + this.ELEMENT_HEIGHT + "\"\n    transform=\"translate(" + textRegion + ", 0)\"></rect>\n  <rect\n    class=\"waveName waveName" + count + " scope\" width=\"1\" height=\"" + this.ELEMENT_HEIGHT + "\"\n    transform=\"scale(" + textRegion + ", 1)\"></rect>";
          if (wave.expanded) {
            expand = "waveCollapse";
            sign = "-";
          } else {
            expand = "waveExpand";
            sign = "+";
          }
          out += "<text class=\"" + expand + "\" x=\"4\" y=\"15\" text-anchor=\"start\" xml:space=\"preserve\"><title></title>" + sign + "</text>";
          out += '<text class="scope" x="16" y="15" text-anchor="start" xml:space="preserve"><title>';
          out += name = wave.name;
          out += "</title>" + name + "</text>";
          out += "<text\n  id=\"value_" + count + "\" class=\"value\" x=\"" + (30 - 4) + "\" y=\"15\" transform=\"translate(" + textRegion + ")\"\n  text-anchor=\"end\">\n  <title></title>\n</text>";
          out += "<g class=\"wave\" transform=\"translate(" + this.textRegionWidth + ", 0)\">\n  <rect class=\"wavescope\" width=\"" + (this.windowWidth - this.textRegionWidth) + "\" height=\"20\"></rect>\n  <text class=\"wavescope\" x=\"4\" y=\"15\" text-anchor=\"start\" xml:space=\"preserve\">\n    <title>" + li + "</title>\n    " + li + "\n   </text>\n </g>\n </g>";
          count++;
          continue;
        }
        le = wave.name;
        li = wave.name;
        if (wave.scope.startsWith(Variable.tlvTopScopeName)) {
          tempName = wave.name.replace(/\[[0-9]+:[0-9]+\]/g, "");
          li = tempName.substring(tempName.indexOf(Variable.tlvTopScopeName) + Variable.tlvTopScopeName.length);
          if (li.indexOf("@") > -1) {
            li = li.substring(0, li.indexOf("@")) + li.substring(li.indexOf("$"));
          }
          le = li.replace(/\[[0-9]+\]/g, "");
        }
        out += '<g transform="translate(0,' + count * this.ELEMENT_HEIGHT + ')" logical_entity="' + le + '" logical_instance="' + li + '">';
        out += "<rect\n  class=\"value\" width=\"" + (this.textRegionWidth - textRegion) + "\" height=\"" + this.ELEMENT_HEIGHT + "\"\n  transform=\"translate(" + textRegion + ",0)\"></rect>\n<rect\n  class=\"waveName waveName" + count + "\" width=\"1\" height=\"" + this.ELEMENT_HEIGHT + "\"\n  transform=\"scale(" + textRegion + ",1)\"></rect>";
        out += "<text class=\"name name" + count + "\" x=\"" + textRegion + "\" y=\"15\" text-anchor=\"end\" xml:space=\"preserve\"><title>";
        fullName = "";
        name = "";
        if ((wave.cycle != null) && wave.cycle !== void 0) {
          index = wave.notFullName.lastIndexOf("$");
          name = ("@" + wave.cycle) + wave.notFullName.substring(index);
          if (wave.name.startsWith(Variable.tlvTopScopeName)) {
            fullName = wave.name.substring(Variable.tlvTopScopeName.length, index) + name;
          } else {
            fullName = wave.name.substring(0, index) + name;
          }
        } else {
          name = wave.notFullName;
          fullName = wave.name;
        }
        out += fullName + ("</title>" + name + "</text>");
        out += "<text\n  id=\"value_" + count + "\" class=\"value\" x=\"" + (30 - 4) + "\" y=\"15\" transform=\"translate(" + textRegion + ")\"\n  text-anchor=\"end\">\n  <title></title>\n</text>";
        out += '<g class="wave" transform="translate(' + this.textRegionWidth + ',0)">';
        out += '<rect width="' + (this.windowWidth - this.textRegionWidth) + '" height="20"></rect>';
        if (wave.type !== "SCOPE") {
          sv = new SignalValue(wave.signal, this.currentStart);
        }
        if (wave.type === "real") {
          out += this.processSignal(sv, pixelsPerCycle, this.drawBusSignal);
        } else {
          if (wave.width === 1 || wave.width === "1") {
            out += this.processSignal(sv, pixelsPerCycle, this.drawBitSignal);
          } else {
            if (wave.width !== 0 && wave.width !== "0") {
              out += this.processSignal(sv, pixelsPerCycle, this.drawBusSignal);
            }
          }
        }
        out += '</g></g>';
        count++;
      }
      return out;
    };


    /*
    create svg row for a multibit signal (bus)
    @param {SignalValue} sv the SignalValue for this signal, initialize to cycle = @currentStart.
    @param {Number} pixelsPerCycle pixels per cycle
    @return {String} the string representation of the svg for this multibit signal
     */

    WaveformGenerator.prototype.processSignal = function(sv, pixelsPerCycle, drawFn) {
      var blur, doDraw, done, endCycle, endPix, lastEndPix, offEnd, offStart, offWave, out, startPix, thisBlur;
      out = "";
      lastEndPix = 0;
      startPix = 0;
      blur = false;
      done = false;
      while (true) {
        endCycle = sv.getNextTransitionCycle();
        offWave = typeof endCycle === "undefined";
        offEnd = offWave || endCycle > this.currentEnd;
        if (offEnd) {
          endCycle = this.currentEnd + 1;
        }
        endPix = Math.round(pixelsPerCycle * (endCycle - this.currentStart));
        done = offWave || endPix >= this.waveRegion;
        if (endPix > lastEndPix) {
          doDraw = endPix - lastEndPix >= 1.5;
          thisBlur = doDraw ? false : sv.isValid() ? (drawFn === this.drawBusSignal ? "ValidBus" : "ValidBit") : typeof sv.isValid() === "undefined" ? "UnkValidity" : "Invalid";
          if (blur && (blur !== thisBlur)) {
            out += this._drawBlur(blur, startPix, lastEndPix);
            startPix = lastEndPix;
          }
          blur = thisBlur;
          if (doDraw) {
            offStart = sv.getTransitionCycle() < sv.getCycle();
            out += drawFn(sv, startPix, endPix, offStart, offEnd);
            startPix = endPix;
          }
          lastEndPix = endPix;
        }
        if (done) {
          out += this._drawBlur(blur, startPix, endPix);
          break;
        }
        sv.goToNextTransition();
      }
      return out;
    };


    /*
    Draw blur of values.
    @param {String} blur mnemonic for the blur type
    @param {int} startPix starting pixel (x-coord)
    @param {int} endPix ending pixel (x-coord)
     */

    WaveformGenerator.prototype._drawBlur = function(blur, startPix, endPix) {
      Utils.assert(Number.isInteger(endPix - startPix));
      return "<use\n  xlink:href=\"#Blur" + blur + "\"\n  transform=\"translate(" + startPix + ",0.49) scale(" + (endPix - startPix) + ",1)\" />";
    };


    /*
    Same interface as drawBusSignal.
     */

    WaveformGenerator.prototype.drawBitSignal = function(sv, startPix, endPix, offStart, offEnd) {
      var dif, group, out;
      dif = endPix - startPix;
      out = "<use\n  xlink:href=\"#" + (this.getLastValue(sv.getLegacyValue(), sv.isValid())) + "\" transform=\"translate(" + startPix + ", 0.5)\n  scale(" + dif + ", 1)\" />";
      if (!offEnd) {
        group = this.getEdge(sv.getValue(), sv.isValid(), sv.getNextTransitionValueStr(), sv.isNextTransitionValid());
        if (group) {
          out += "<use xlink:href=\"#" + group + "\" transform=\"translate(" + endPix + ", 0.5)\"/>";
        }
      }
      return out;
    };


    /*
    Determines which ID to use for a bus, given the results from getBusIntervalText
     */

    WaveformGenerator.prototype.busID = function(allX, valid) {
      if (allX || typeof valid === "undefined") {
        return "#xbus";
      } else if (valid) {
        return "#bus";
      } else {
        return "#DCBus";
      }
    };


    /*
    draw one value and one change for a multiwire signal (bus)
    @param {SignalValue} sv the signal value to draw
    @param {int} startPix the starting pixel
    @param {int} endPix the ending pixel
    @param {Boolean} offStart true if the transition creating this value occurred outside of view.
    @param {Boolean} offEnd true if the transition ending this value occurs outside of view.
    @return {Array<String, int>} the string representation for the svg data for this value and transition,
                                 and the end x position of the value.
     */

    WaveformGenerator.prototype.drawBusSignal = function(sv, startPix, endPix, offStart, offEnd) {
      var allX, midDist, out, ref1, temp;
      if (offStart) {
        startPix -= 1.5;
      }
      midDist = endPix - startPix - 3;
      if (offEnd) {
        midDist = this.waveRegion - startPix - 1.5;
      }
      out = "";
      ref1 = this.getBusIntervalText(sv, sv.getLegacyValue(), midDist, startPix), allX = ref1[0], temp = ref1[1];
      if (!offStart) {
        out += "<use\n  xlink:href=\"" + (this.busID(allX, sv.isValid())) + "Start\"\n  transform=\"translate(" + startPix + ", 0.5)\" />";
      }
      if (midDist > 0) {
        out += "<use\n  xlink:href=\"" + (this.busID(allX, sv.isValid())) + "\"\n  transform=\"translate(" + (startPix + 1.5) + ", 0.5) scale(" + midDist + ",1)\" />";
        out += temp;
      }
      if (!offEnd) {
        out += ("<use xlink:href=\"" + (this.busID(allX, sv.isValid())) + "End\"") + (" transform=\"translate(" + (endPix - 1.5) + ", 0.5)\" />");
      }
      return out;
    };


    /*
    gets group to extend to right edge of svg
    @param {Number, String} val the last value of the signal
    @return {String} the last value
     */

    WaveformGenerator.prototype.getLastValue = function(value, valid) {
      switch (value) {
        case 0:
        case "0":
          return "zero";
        case 1:
        case "1":
          return "one";
        case "Z":
          return "z";
        case "W0":
          if (valid === false) {
            return "DCZero";
          } else {
            return "UnkDCZero";
          }
        case "W1":
          if (valid === false) {
            return "DCOne";
          } else {
            return "UnkDCOne";
          }
        default:
          return "x";
      }
    };


    /*
    gets transition edge between two signal values for a single bit signal
    @param {String} last the value (as VCD value string) before the transition
    @param {Boolean, undefined} lastValid validity of last value
    @param {String} next the value (as VCD value string) after the transition
    @param {Boolean, undefined} nextValid validity of next value
    @return {String} the transition edge type
     */

    WaveformGenerator.prototype.getEdge = function(last, lastValid, next, nextValid) {
      if (next === last) {
        return "";
      } else {
        if (next === "X" || typeof nextValid === "undefined") {
          return "xEdge";
        }
        switch (last) {
          case "0":
            return this.getEdgeFromZero(next, nextValid);
          case "1":
            return this.getEdgeFromOne(next, nextValid);
          case "Z":
            return this.getEdgeFromZ(next, nextValid);
          case "X":
            return "xEdge";
          case "W0":
            return this.getEdgeFromDCZero(next, nextValid);
          case "W1":
            return this.getEdgeFromDCOne(next, nextValid);
          default:
            return "";
        }
      }
    };


    /*
    gets transition edge from zero to the next value
    @param {Number, String} next the next value of the signal
    @param {Boolean} nextValid validity of next value
    @return {String} the transition edge type
     */

    WaveformGenerator.prototype.getEdgeFromZero = function(next, nextValid) {
      switch (next) {
        case "1":
          return (nextValid ? "risingEdge" : "DCBitEdge");
        case "Z":
          return "zeroToZ";
      }
      return "";
    };


    /*
    gets transition edge from one to the next value
    @param {Number, String} next the next value of the signal
    @param {Boolean} nextValid validity of next value
    @return {String} the transition edge type
     */

    WaveformGenerator.prototype.getEdgeFromOne = function(next, nextValid) {
      switch (next) {
        case "0":
          return (nextValid ? "fallingEdge" : "DCBitEdge");
        case "Z":
          return "oneToZero";
      }
      return "";
    };


    /*
    gets transition edge from Z to the next value
    @param {Number, String} next the next value of the signal
    @param {Boolean} nextValid validity of next value
    @return {String} the transition edge type
     */

    WaveformGenerator.prototype.getEdgeFromZ = function(next, nextValid) {
      switch (next) {
        case "0":
          return (nextValid ? "ZToZero" : "ZToDCZero");
        case "1":
          return (nextValid ? "ZToOne" : "ZToDCOne");
      }
      return "";
    };


    /*
    gets transition edge from don't care zero to next value
    @param {Number, String} next the next value of the signal
    @param {Boolean} nextValid validity of next value
    @return {String} the transition edge type
     */

    WaveformGenerator.prototype.getEdgeFromDCZero = function(next, nextValid) {
      switch (next) {
        case "1":
          return (nextValid ? "risingEdge" : "DCBitEdge");
        case "Z":
          return "DCZeroToZ";
      }
      return "";
    };


    /*
    gets transitionedge from don't care one to next value
    @param {Number, String} next the next value of the signal
    @param {Boolean} nextValid validity of next value
    @return {String} the transition edge type
     */

    WaveformGenerator.prototype.getEdgeFromDCOne = function(next, nextValid) {
      switch (next) {
        case "0":
          return (nextValid ? "fallingEdge" : "DCBitEdge");
        case "Z":
          return "DCOneToZ";
      }
      return "";
    };


    /*
    gets the interval size between major marks
    @param {Number} start the starting cycle
    @param {Number} end the end cycle
    @return {Number} the major mark interval size
     */

    WaveformGenerator.prototype.getIntervalSize = function(start, end) {
      var f, k, numPixelWidth, width;
      width = end - start;
      numPixelWidth = this.addCommas(end * this.timescale.number).length * 8;
      f = width / (this.waveRegion / Math.max(numPixelWidth, 100));
      k = 1;
      while (f > 50) {
        k *= 10;
        f /= 10;
      }
      if (f <= 10) {
        return 10 * k;
      } else {
        if (f <= 20) {
          return 20 * k;
        } else {
          if (f <= 50) {
            return 50 * k;
          }
        }
      }
    };


    /*
    gets text that displays in a single bus value region
    @param {Number} lastValue the value of the bus region
    @param {Number} dif the space for the text
    @param {Number} roundLoc the location for the text
    @return {String} the string representation of the html for this text
     */

    WaveformGenerator.prototype.getBusIntervalText = function(sv, lastValue, dif, roundLoc) {
      var allX, j, len1, ref1, style, temp, text, val, valid, x;
      valid = sv.isValid();
      val = sv.signal.type !== "real" ? this.getBusIntervalValue(sv.getValue(), sv.signal.width) : sv.getValue();
      text = this.shortenText(val, dif);
      allX = true;
      ref1 = val.split("");
      for (j = 0, len1 = ref1.length; j < len1; j++) {
        x = ref1[j];
        if (x !== "X" && x !== "x" && x !== "_") {
          allX = false;
        }
      }
      if (text) {
        style = allX || typeof valid === "undefined" ? 'style="fill:crimson" ' : valid ? "" : 'style="fill:gray" ';
        temp = "<text class=\"busData\" x=\"0\" y=\"14\" " + style + " transform=\"translate(" + (roundLoc + 2.5) + ")\">\n  <title>" + val + "</title>\n  " + text + "\n</text>";
        return [allX, temp];
      }
      return [false, ""];
    };


    /*
    get bus value to display in bus section
    @param {Number} val the value
    @param {Number} width the bitwidth of the signal
    @return {String} the string representation of the value in the correct base system
     */

    WaveformGenerator.prototype.getBusIntervalValue = function(val, width) {
      if (this.radix === "hex") {
        return valToHex(val, width);
      } else {
        return valToBin(val, width);
      }
    };


    /*
    shortens text to fit in bus section
    @param {String} val the text representation of the bus value
    @param {String} dif the space for the text
    @return {String} the shortened text
     */

    WaveformGenerator.prototype.shortenText = function(val, dif) {
      var space;
      if (dif > 0) {
        space = Math.floor(dif / 8);
      } else {
        space = 0;
      }
      if (val.length > space) {
        if (space === 0) {
          return "";
        } else {
          if (space === 1) {
            return "*";
          } else {
            return "*" + val.substring(val.length - space + 1);
          }
        }
      }
      return val;
    };


    /*
    inserts commas into a number as appropriate
    @param {Number, String} num the number to add commas to
    @return {String} the number with commas inserted
     */

    WaveformGenerator.prototype.addCommas = function(num) {
      return num.toString().replace(/\B(?=(\d{3})+(?!\d))/g, ",");
    };

    return WaveformGenerator;

  })();


  /*
  converts binary value to hex
  @param {String} val the binary value
  @param {Number} width the bitwidth of the signal
  @return {String} the value as a hex string
   */

  valToHex = function(val, width) {
    var bytes, c, j, maxBytes, out, ref1, temp;
    val = "" + val;
    out = valToHexChunks(val);
    out = valToHexRemainder(val, out);
    if (width > val.length) {
      temp = null;
      if (val[0] === "z") {
        temp = "Z";
      } else {
        if (val[0] === "x") {
          temp = "X";
        }
      }
      if (temp) {
        maxBytes = Math.ceil(width / 4);
        bytes = Math.ceil(val.length / 4);
        for (c = j = 0, ref1 = maxBytes - bytes; 0 <= ref1 ? j < ref1 : j > ref1; c = 0 <= ref1 ? ++j : --j) {
          out = appendHexChunk(out, temp);
        }
      }
    }
    return out.split("").reverse().join("");
  };


  /*
  converts binary value to hex in four bit chunks (does not get tail)
  @param {String} val the value to convert to hex
  @return {String} the hex string (tail not converted)
   */

  valToHexChunks = function(val) {
    var arr, chunk, hex, i, index, j, len1, out;
    out = "";
    arr = [];
    index = val.length - 4;
    while (index >= 0) {
      arr.push(index);
      index -= 4;
    }
    for (j = 0, len1 = arr.length; j < len1; j++) {
      i = arr[j];
      chunk = val.substr(i, 4);
      if (chunk === "xxxx") {
        hex = "X";
      } else {
        if (chunk === "zzzz") {
          hex = "Z";
        } else {
          if (chunk.indexOf("x") >= 0) {
            hex = "x";
          } else {
            if (chunk.indexOf("z") >= 0) {
              hex = "z";
            } else {
              hex = parseInt(chunk, 2).toString(16);
            }
          }
        }
      }
      out = appendHexChunk(out, hex);
    }
    return out;
  };


  /*
  converts the tail of a binary number to hex
  @param {String} val the partially converted hex string
  @param {String} front the first part of the output hex string
  @return {String} the whole number in hex
   */

  valToHexRemainder = function(val, front) {
    var hex, small;
    if (val.length % 4) {
      small = val.substr(0, val.length % 4);
      if (small === "x" || small === "xx" || small === "xxx") {
        hex = "X";
      } else {
        if (small === "z" || small === "zz" || small === "zzz") {
          hex = "Z";
        } else {
          if (small.indexOf("x") >= 0) {
            hex = "x";
          } else {
            if (small.indexOf("z") >= 0) {
              hex = "z";
            } else {
              hex = parseInt(small, 2);
            }
          }
        }
      }
      front = appendHexChunk(front, hex);
    }
    return front;
  };


  /*
  converts to a binary string
  @param {String} val the number to convert
  @param {Number} width the bitwidth of the signal
  @return {String} the binary value with x's and z's added as needed
   */

  valToBin = function(val, width) {
    var c, j, more, na, ref1, space;
    if (width > val.length) {
      na = null;
      if (val[0] === "z") {
        na = "z";
      } else {
        if (val[0] === "x") {
          na = "x";
        }
      }
      if (na) {
        more = "";
        space = width - val.length;
        for (c = j = 0, ref1 = space; 0 <= ref1 ? j < ref1 : j > ref1; c = 0 <= ref1 ? ++j : --j) {
          more += na;
        }
        return more + val;
      }
    }
    return val;
  };


  /*
  puts together hex chunks with underscore if necessary
  @param {String} large the main string of the hex value
  @param {String} next the chunk to append
  @return {String} next appended to large, with underscore if necessary
   */

  appendHexChunk = function(large, next) {
    if (large.length !== 4 && ((large.length + 1) % 5)) {
      return large += next;
    }
    return large += "_" + next;
  };


  /*
  determines whether the input is a number
  @param {Number, String, ...} num value of any type to test if type is Number of some sort
  @return {Boolean} true if num is a {Number}, else false
   */

  isNumber = function(num) {
    return !isNaN(num - 0) && (typeof a !== "undefined" && a !== null) && a !== false && a !== "";
  };

  define(function(require, exports, module) {
    $ = require("jquery");
    Utils = require("Utils");
    SignalValue = require("VCD/SignalValue");
    Variable = require("VCD/Variable");
    $.extend(WaveformGenerator.prototype, module.config());
    return WaveformGenerator;
  });

}).call(this);
