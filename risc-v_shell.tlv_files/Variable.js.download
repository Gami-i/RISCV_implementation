(function() {
  var $, SignalValue, Utils, Variable, ref,
    slice = [].slice;

  ref = [], $ = ref[0], Utils = ref[1], SignalValue = ref[2];


  /*
  A signal and its waveform.
  TODO: Rename to Signal.
   */

  Variable = (function() {
    Variable.prototype.waveData = null;

    Variable.prototype.conditions = null;

    Variable.prototype.cycle = null;

    Variable.prototype.width = null;

    Variable.prototype.notFullName = null;

    Variable.prototype.type = null;

    Variable.prototype.nickname = null;

    Variable.prototype.fullName = null;

    Variable.prototype.scope = null;

    Variable.prototype.ports = null;

    Variable.prototype.depth = null;


    /*
    @property {Array} waveform data in the form:
    [ <cycle>,  # Cycle number of the transition
      <value-str>, # As in VCD file.
      <valid>,  # Boolean or undefined (for conditions outside trace). (Note, this is wasted space
                 * for signals w/o conditions, including all SV signals.)
      (repeat)
    ]
    Presumably, using a flat array is optimal for storage and lookup time.
     */

    Variable.prototype.transitions = null;


    /*
    @property {Array<int>} Course-grained indexing into @transitions by time.
                           The value of a signal at cycle X can be found by
                           starting at transitions[anchors[(X - @waveData.startCycle) / TIME_SLOT_WIDTH]]
                           and scanning forward.
     */

    Variable.prototype.anchors = null;

    Variable.TIME_SLOT_WIDTH = null;

    Variable.TRANSITION_FIELDS = null;

    Variable.staticInit = function(TSW, TF) {
      Variable.TIME_SLOT_WIDTH = TSW;
      return Variable.TRANSITION_FIELDS = TF;
    };


    /*
    @param {WaveData} waveData the {WaveData}
    @param {Number} width the width of the signal
    @param {String} name the name of the signal
    @param {String} nickname the vcd nickname representation of the signal
    @param {String} scope the scope of the signal
    @param {String} type the type of the signal
    @param {String} ports the '[3:0]' representation of the bit range of this signal
     */

    function Variable(waveData, width, name, nickname, scope1, type, ports1, depth1) {
      var c, char, conditionstr, index, indicies, scopeHeader, scopeTail;
      this.waveData = waveData;
      this.width = width;
      this.nickname = nickname;
      this.scope = scope1;
      this.type = type;
      this.ports = ports1;
      this.depth = depth1;
      this.conditions = [];
      this.cycle = null;
      if (this.isTlvSig()) {
        if (name.indexOf("?") === -1) {
          if (name.indexOf(">") !== -1) {
            this.notFullName = name.substring(name.lastIndexOf(">") + 1);
          }
          if (name.indexOf("@") > -1) {
            this.notFullName = name.substring(name.indexOf("$"));
            this.cycle = parseInt(name.substring(name.indexOf("@") + 1, name.lastIndexOf("$")));
          }
        } else {
          this.fullName = name.substring(name.lastIndexOf("@"));
          this.notFullName = name.substring(name.lastIndexOf("$"));
          this.cycle = parseInt(name.substring(name.indexOf("@") + 1, name.lastIndexOf("$")));
          conditionstr = name.substring(0, name.lastIndexOf("@"));
          scopeHeader = Variable.tlvTopScopeName;
          scopeTail = this.scope.substring(Variable.tlvTopScopeName.length);
          while (conditionstr.length > 0) {
            if (conditionstr.charAt(0) === ">") {
              if (scopeTail.length === 0) {
                console.log("In when condition, tried to go too deep in scope");
              }
              indicies = ((function() {
                var i, len, ref1, results;
                ref1 = ["/", ">", "|"];
                results = [];
                for (i = 0, len = ref1.length; i < len; i++) {
                  char = ref1[i];
                  results.push(scopeTail.indexOf(char, 1));
                }
                return results;
              })()).filter(function(x) {
                return x >= 0;
              });
              index = Math.min.apply(Math, slice.call(indicies).concat([scopeTail.length]));
              scopeHeader += scopeTail.substring(0, index);
              scopeTail = scopeTail.substring(index);
              conditionstr = conditionstr.substring(1);
            } else {
              conditionstr = conditionstr.substring(1);
              indicies = ((function() {
                var i, len, ref1, results;
                ref1 = ["$", "?", ">"];
                results = [];
                for (i = 0, len = ref1.length; i < len; i++) {
                  char = ref1[i];
                  results.push(conditionstr.indexOf(char, 1));
                }
                return results;
              })()).filter(function(x) {
                return x >= 0;
              });
              index = Math.min.apply(Math, slice.call(indicies).concat([conditionstr.length]));
              c = conditionstr.substring(0, index);
              conditionstr = conditionstr.substring(index);
              this.conditions.push(scopeHeader + c);
            }
          }
        }
        this.fullName = (this.scope + this.notFullName).trim();
      } else {
        this.notFullName = name;
        this.fullName = (((this.scope.length === 0) ? "" : this.scope + ".") + this.notFullName).trim();
      }
    }


    /*
    Set transitions, and anchors.
    @param {Array} transitions
    @param {Array} anchors
     */

    Variable.prototype._setTransitions = function(transitions, anchors) {
      this.transitions = transitions;
      this.anchors = anchors;
    };

    Variable.tlvTopScopeName = "TLV";


    /*
    Get the value string at given time.
    @param {int} time (within trace)
    @return {String} value string
     */

    Variable.prototype.getValueAtCycle = function(cyc) {
      return this.transitions[this.getTransIndexOfCycle(cyc) + 1];
    };


    /*
    Get the value and its validity at the given cycle.
    @param {Number} cyc (phase-granular) cycle within trace bounds
    @return {[String, boolean]} value string and its validity
     */

    Variable.prototype.getValueAndValidAtCycle = function(cyc) {
      var transIndex;
      transIndex = this.getTransIndexOfCycle(cyc);
      return [this.transitions[transIndex + 1], this.transitions[transIndex + 2]];
    };


    /*
    Get the index into transitions array that produces the value at the given cycle (by indexing into anchors,
    and searching forward).
    @param {Number} cyc the (phase-granular) cycle (within trace bounds)
    @return {int} index into transitions array (can be one transition before first, or
                  last transition if after last
     */

    Variable.prototype.getTransIndexOfCycle = function(cyc) {
      var nextCycle, nextIndex, transIndex;
      if (cyc < this.waveData.startCycle) {
        return -SignalValue.TRANSITION_FIELDS;
      }
      if (cyc >= this.waveData.lastCycle) {
        return this.transitions.length - SignalValue.TRANSITION_FIELDS;
      }
      transIndex = this.anchors[Math.floor((cyc - this.waveData.startCycle) / Variable.TIME_SLOT_WIDTH)];
      while (true) {
        nextIndex = transIndex + SignalValue.TRANSITION_FIELDS;
        nextCycle = this.transitions[nextIndex];
        if (typeof nextCycle === "undefined" || nextCycle > cyc) {
          break;
        }
        transIndex = nextIndex;
      }
      return transIndex;
    };


    /*
    makes a Variable from a line of vcd and current scope
    @param {Array<String>} c line of a .vcd file declaring a variable, which is in array format split by word
    @param {String} scope the current scope
    @return {Variable}
     */

    Variable._makeVar = function(wd, c, scope, depth) {
      var ports, v;
      ports = c.length > 4 ? c[4] : null;
      return v = new Variable(wd, c[1], c[3], c[2], scope, c[0], ports, depth);
    };

    Variable.prototype.isTlvSig = function() {
      return this.scope.startsWith(Variable.tlvTopScopeName);
    };

    return Variable;

  })();

  define(function(require, exports, module) {
    $ = require("jquery");
    Utils = require("Utils");
    SignalValue = require("VCD/SignalValue");
    $.extend(Variable.prototype, module.config());
    return Variable;
  });

}).call(this);
