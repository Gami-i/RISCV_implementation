
/*
Redwood EDA
original author: Alex DeFiore
 */

(function() {
  var ScopeVariable, SignalValue, Utils, Variable, WaveData, ref,
    indexOf = [].indexOf || function(item) { for (var i = 0, l = this.length; i < l; i++) { if (i in this && this[i] === item) return i; } return -1; },
    hasProp = {}.hasOwnProperty;

  ref = [], Variable = ref[0], ScopeVariable = ref[1], SignalValue = ref[2], Utils = ref[3];


  /*
  WaveData class stores waveform data from a VCD file.
   */

  WaveData = (function() {
    WaveData.prototype.TIME_SLOT_WIDTH = 10;

    WaveData.prototype.TRANSITION_FIELDS = 3;

    WaveData.prototype.timescale = null;

    WaveData.prototype.signals = null;

    WaveData.prototype.lastTime = -1;

    WaveData.prototype.endCycle = -1;

    WaveData.prototype.start = 2e308;

    WaveData.prototype.startCycle = 2e308;

    WaveData.prototype.names = null;

    WaveData.prototype.numSignals = 0;

    WaveData.prototype.numTlvSignals = 0;

    WaveData.prototype.cycleLength = 2;

    WaveData.prototype.resetDuration = 5;

    WaveData.prototype.cycleZeroTime = 10;

    function WaveData(src) {
      SignalValue.staticInit(this.TIME_SLOT_WIDTH, this.TRANSITION_FIELDS);
      Variable.staticInit(this.TIME_SLOT_WIDTH, this.TRANSITION_FIELDS);
      this.updateData(src);
    }


    /*
    updates the information contained within the instance of WaveData
    @param {String} src is the source of the new vcd data
     */

    WaveData.prototype.updateData = function(src) {
      if (src != null) {
        this.parseData(src);
      } else {
        this.parseData(getVcd());
      }
      this.verifyTrace();
      this.lookupConditionSignals();
      return this.generateInvalids();
    };


    /*
    Add a signal transition from the vcd.
     */

    WaveData.addPoint = function(wavesByNickname, nickname, cyc, value) {
      if (wavesByNickname[nickname]) {
        return wavesByNickname[nickname].transitions.push(cyc, value, true);
      }
    };


    /*
    Convert VCD time to cycle
    @param {int} time
    @return {Number} cycle (int or int.5)
     */

    WaveData.prototype.timeToCycle = function(time) {
      return (time - this.cycleZeroTime) / this.cycleLength;
    };


    /*
    Parses a .vcd file into signals and waveform data into signals[<name>].data.
    Top-level VCD hierarchy is modified.  VCD contains hierarchy like:
    ```
    TOP
      ...
      top
        clk
        reset
        DEBUG_SIGS -> TLV
          ...
        sv_sig1
        sv_scope1
          etc
    clk
    reset
    >top (from DEBUG_SIGS)
      ...
    SV (from top)
      ...
    ```
    
    @param {String} input the input string to parse
     */

    WaveData.prototype.parseData = function(input) {
      var anchors, carrier, currentScope, currentTime, currentVcdScope, date, debugSigsDepth, debugSigsScope, depth, fullName, id, inDebugSigs, index, item, j, k, l, len1, len2, len3, letters, lines, m, n, next, nickname, ref1, ref2, ref3, ref4, rootScope, setEnd, skipTwo, svScope, svVars, temp, tlvTopScope, tlvVars, topVars, tot, ts, v, value, vars, vcdScopes, version, w, wave, wavesByNickname, words;
      lines = input.split("\n");
      lines = (function() {
        var j, len1, results;
        results = [];
        for (j = 0, len1 = lines.length; j < len1; j++) {
          item = lines[j];
          if (item.length > 0) {
            results.push(item);
          }
        }
        return results;
      })();
      w = [];
      for (j = 0, len1 = lines.length; j < len1; j++) {
        l = lines[j];
        w.push(l.trim());
      }
      words = [];
      for (m = 0, len2 = w.length; m < len2; m++) {
        l = w[m];
        words.push.apply(words, l.split(" "));
      }
      words = (function() {
        var len3, n, results;
        results = [];
        for (n = 0, len3 = words.length; n < len3; n++) {
          item = words[n];
          if (item.trim().length > 0) {
            results.push(item);
          }
        }
        return results;
      })();
      carrier = [];
      currentTime = -1;
      rootScope = new ScopeVariable("", null, 0);
      svScope = new ScopeVariable("SV", rootScope, 1);
      tlvTopScope = new ScopeVariable("TLV", rootScope, 1);
      currentScope = rootScope;
      ts = "";
      version = "";
      depth = -1;
      setEnd = false;
      inDebugSigs = false;
      debugSigsScope = null;
      debugSigsDepth = -1;
      vcdScopes = [];
      currentVcdScope = null;
      this.numTlvSignals = 0;
      wavesByNickname = {};
      svVars = {};
      topVars = {};
      tlvVars = {};

      /*
      Examples of vcd lines (this loop stops before reaching signal data and transitions)
      $var:
        $var wire  1 v clk $end
        results in
        temp = ['wire', '1', 'v', 'clk']
      $date:
        $date Mon Aug  8 09:40:42 2016 $end
      $version:
        $version Generated by VerilatedVcd $end
      $timescale:
        $timescale   1ns $end
      $scope:
        $scope module TOP $end
        $scope module sigs [0] $end
        results in
        temp = ['module', 'TOP']
        temp = ['module', 'sigs', '[0]']
      $upscope:
        $upscope $end
       */
      index = 0;
      while ((words != null) && words[index] !== "$dumpvars" && !setEnd && index < words.length) {
        next = words[index];
        index++;
        if (next === "$end" && carrier.length > 0) {
          id = carrier.shift();
          temp = carrier;
          carrier = [];
          switch (id) {
            case "$date":
              date = temp;
              break;
            case "$version":
              version = temp;
              break;
            case "$timescale":
              ts = temp;
              break;
            case "$var":
              if ((currentScope !== rootScope) || (currentVcdScope === "TOP" && ((temp[3] === "clk") || (temp[3] === "reset")))) {
                v = Variable._makeVar(this, temp, currentScope.name, currentScope.depth);
                if (currentScope === rootScope) {
                  topVars[v.fullName] = null;
                } else if (inDebugSigs) {
                  tlvVars[v.fullName] = null;
                  this.numTlvSignals++;
                } else {
                  svVars[v.fullName] = null;
                }
                if (!wavesByNickname[v.nickname]) {
                  wavesByNickname[v.nickname] = {
                    vars: [],
                    transitions: []
                  };
                }
                wavesByNickname[v.nickname].vars.push(v);
              }
              break;
            case "$scope":
              currentVcdScope = temp[1];
              vcdScopes.push(currentVcdScope);
              if ((currentScope === rootScope) && (currentVcdScope === "top")) {
                currentScope = svScope;
                depth = 1;
              } else if (currentVcdScope === "DEBUG_SIGS") {
                debugSigsScope = currentScope;
                debugSigsDepth = depth;
                depth = 1;
                currentScope = tlvTopScope;
                inDebugSigs = true;
              } else if (depth >= 0) {
                depth++;
                if (temp.length >= 2) {
                  currentScope = new ScopeVariable(currentVcdScope, currentScope, depth, temp.length > 2 ? temp[2] : "");
                } else {
                  console.log("VCD file contains malformed $scope line: " + temp);
                }
              }
              break;
            case "$upscope":
              if (currentScope === tlvTopScope) {
                currentScope = debugSigsScope;
                depth = debugSigsDepth;
                inDebugSigs = false;
              } else if (currentScope === svScope) {
                currentScope = rootScope;
                depth === -1;
              } else if (currentScope !== rootScope) {
                currentScope = currentScope.parent;
                depth--;
              }
              currentVcdScope = vcdScopes.pop();
              break;
            case "$enddefinitions":
              setEnd = true;
              break;
            default:
              console.log("unexpected identifier: " + id + "\n");
          }
        } else {
          carrier.push(next);
        }
      }
      vars = {};
      for (fullName in topVars) {
        vars[fullName] = topVars[fullName];
      }
      for (fullName in tlvVars) {
        vars[fullName] = tlvVars[fullName];
      }
      for (fullName in svVars) {
        vars[fullName] = svVars[fullName];
      }
      while (index < words.length && ((ref1 = words[index]) !== "$dumpvars" && ref1 !== "#0")) {
        index++;
      }
      skipTwo = words[index] === "#0";
      if (!skipTwo) {
        index++;
      }
      currentTime = 0;
      while (!skipTwo && (words != null) && index < words.length && (words[index] != null) && words[index] !== "$end") {
        next = words[index];
        index++;
        letters = next.split("");
        nickname = "";
        value = "";
        if ((ref2 = parseInt(letters[0]), indexOf.call([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], ref2) >= 0) || (letters[0] === "x")) {
          nickname = letters.slice(1).toString();
          value = letters[0];
        } else {
          nickname = words[index];
          index++;
          value = next.substring(1);
        }
        WaveData.addPoint(wavesByNickname, nickname, this.timeToCycle(currentTime), value);
      }
      if (!skipTwo) {
        index++;
      }
      while ((words != null) && index < words.length && (words[index] != null)) {
        next = words[index];
        index++;
        letters = next.split("");
        nickname = "";
        value = "";
        if (letters[0] === "#") {
          currentTime = parseInt(next.substring(1));
          if (currentTime < this.start) {
            this.start = currentTime;
          }
        } else {
          if ((ref3 = parseInt(letters[0]), indexOf.call([0, 1, 2, 3, 4, 5, 6, 7, 8, 9], ref3) >= 0) || letters[0] === "x") {
            nickname = next.substring(1);
            value = letters[0];
          } else {
            nickname = words[index];
            index++;
            value = next.substring(1);
          }
          WaveData.addPoint(wavesByNickname, nickname, this.timeToCycle(currentTime), value);
        }
      }
      this.lastTime = currentTime;
      this.timescale = {
        number: "",
        unit: ""
      };
      if (ts.length > 1) {
        this.timescale.number = parseInt(ts[0], 10);
        this.timescale.unit = ts[1];
      } else {
        index = 1;
        ts = ts[0].trim();
        while (!isNaN(ts.substring(0, index)) && index <= ts.length) {
          index++;
        }
        this.timescale.number = parseInt(ts.substring(0, index), 10);
        this.timescale.unit = ts.substring(index - 1);
      }
      this.startCycle = this.timeToCycle(this.start);
      Utils.assert(this.startCycle === -this.resetDuration, "Trace does not begin with expected reset period.");
      this.endCycle = this.timeToCycle(this.lastTime);
      this.lastTime += this.cycleLength / 2;
      tot = 0;
      for (nickname in wavesByNickname) {
        wave = wavesByNickname[nickname];
        anchors = null;
        ref4 = wave.vars;
        for (n = 0, len3 = ref4.length; n < len3; n++) {
          v = ref4[n];
          if (anchors === null && v.conditions.length === 0) {
            anchors = this.computeAnchors(wave.transitions);
          }
          v._setTransitions(wave.transitions, anchors);
          if (vars[v.fullName] != null) {
            console.log("ERROR: Multiple signals with the same name");
          } else {
            vars[v.fullName] = v;
          }
        }
      }
      this.signals = vars;
      this.names = (function() {
        var ref5, results;
        ref5 = this.signals;
        results = [];
        for (k in ref5) {
          if (!hasProp.call(ref5, k)) continue;
          v = ref5[k];
          results.push(v.fullName);
        }
        return results;
      }).call(this);
      return this.numSignals = this.names.length;
    };


    /*
    Determine anchors according to transitions.
    @param {Array} transitions the transitions array (see {Variable})
    @return {Array} anchors (see {Variable})
     */

    WaveData.prototype.computeAnchors = function(transitions) {
      var anchorPt, anchors, cyc, done, i, len, trans;
      Utils.assert(transitions[0] === this.startCycle, "Expected signal waveform to start at cycle " + this.startCycle + ".");
      len = Math.round(transitions.length / this.TRANSITION_FIELDS);
      anchors = [];
      anchorPt = 0;
      trans = 0;
      done = false;
      while (!done) {
        i = trans * this.TRANSITION_FIELDS;
        if (trans < len) {
          cyc = transitions[i];
        } else {
          done = 1;
          cyc = this.endCycle + 1;
        }
        while (cyc > this.anchorIndexToCycle(anchorPt)) {
          anchors[anchorPt] = i - this.TRANSITION_FIELDS;
          anchorPt++;
        }
        trans++;
      }
      return anchors;
    };


    /*
    Translate an anchor index to its cycle.
    @param {int} i
    @return {Number} the phase-granular cycle number
     */

    WaveData.prototype.anchorIndexToCycle = function(i) {
      return i * this.TIME_SLOT_WIDTH + this.startCycle;
    };


    /*
    returns the stored timescale
    @return {Object} timescale
     */

    WaveData.prototype.getTimescale = function() {
      return this.timescale;
    };


    /*
    returns the stored start cycle
    @return {Number} the start cycle
     */

    WaveData.prototype.getStartCycle = function() {
      return this.startCycle;
    };


    /*
    returns the stored end cycle
    @return {Number} the end cycle ((phase-granular) cycle of last transition in trace)
     */

    WaveData.prototype.getEndCycle = function() {
      return this.endCycle;
    };


    /*
    @returns {Number} the end cycle number to view in the waveform viewer.
     */

    WaveData.prototype.getEndViewerCycle = function() {
      return this.endCycle + 0.5;
    };


    /*
    returns the list of signals which also contains their data, name, scope, type, width
    @return {Object} the signals
     */

    WaveData.prototype.getSignals = function() {
      return this.signals;
    };


    /*
    returns how many signals are stored in this WaveData
    @return {Number} the number of signals
     */

    WaveData.prototype.getNumSignals = function() {
      return this.numSignals;
    };


    /*
    returns a list of the names of every signal stored in this WaveData
    @return {Array<String>} all of the signal names
     */

    WaveData.prototype.getSignalNames = function() {
      return this.names;
    };


    /*
    returns the scope of the signal by the given name
    @param {String} name the name of the desired signal
    @return {String} the scope name
     */

    WaveData.prototype.getScopeByName = function(name) {
      if (this.signals[name] != null) {
        return this.signals[name].scope;
      }
      return "";
    };


    /*
    returns the value of the signal by the given name, at the given cycle
    @param {String} name the name of the desired signal
    @param {Number} cyc the cycle of the desired value
    @return {SignalValue} the corresponding {SignalValue} or null if no such signal
     */

    WaveData.prototype.getSignalValueAtCycleByName = function(name, cyc) {
      var sig;
      sig = this.getSignalByName(name);
      if (!sig) {
        return null;
      }
      return new SignalValue(sig, cyc);
    };


    /*
    returns a signal with the given name
    @param {String} name the name of the desired signal
    @return {Object} the signal
     */

    WaveData.prototype.getSignalByName = function(name) {
      if (this.signals[name] != null) {
        return this.signals[name];
      } else {
        return null;
      }
    };


    /*
    Make sure "clk" and reset match expectations.
     */

    WaveData.prototype.verifyTrace = function() {
      var check, clk, reset;
      Utils.assert(Number.isInteger(this.startCycle), "Trace does not begin on an even cycle boundary.");
      clk = this.getSignalByName("clk");
      reset = this.getSignalByName("SV.reset");
      Utils.assert((clk != null) && (reset != null), "Trace is missing clk or reset signal.");
      clk = new SignalValue(clk, 0);
      reset = new SignalValue(reset, 0);
      clk.stepTransition(2);
      check = this.endCycle <= this.resetDuration || (clk.getCycle() === 1 && reset.getTransitionCycle() === reset.getCycle());
      return Utils.assert(check, "Clk and reset signals do not match assumptions.");
    };


    /*
    Transforms @signals.conditions from strings to {Variable}'s.
     */

    WaveData.prototype.lookupConditionSignals = function() {
      var condSig, condition, conditions, j, len1, name, newCond, ref1, results, sig;
      ref1 = this.signals;
      results = [];
      for (name in ref1) {
        if (!hasProp.call(ref1, name)) continue;
        sig = ref1[name];
        newCond = [];
        conditions = sig.conditions;
        for (j = 0, len1 = conditions.length; j < len1; j++) {
          condition = conditions[j];
          condSig = this.getSignalByName(condition);
          if (condSig == null) {
            console.log("Can't find condition signal: " + condition + " for signal " + name);
          } else {
            newCond.push(condSig);
          }
        }
        results.push(sig.conditions = newCond);
      }
      return results;
    };


    /*
    For each signal that has conditions, generate a new waveform for the signal that incorporates
    invalidity, and associate it with the signal.
    Conditions outside the trace result in undefined validity values.
    Note that conditions that are themselves invalid should be shadowed by another invalid condition in proper
      TLV code. We do not check this here. (Doing so would require outer-scope signals to be processed before inners.)
     */

    WaveData.prototype.generateInvalids = function() {
      var cond, condCycle, condSig, condValid, conditions, cyc, j, len1, len2, len3, m, n, name, newTrans, nextCycle, origTrans, origTransCycle, prevValid, prevValue, ref1, ref2, results, sig, transIndex, valid;
      ref1 = this.signals;
      results = [];
      for (name in ref1) {
        if (!hasProp.call(ref1, name)) continue;
        sig = ref1[name];
        sig.conditions;
        origTrans = sig.transitions;
        if (sig.conditions.length > 0) {
          newTrans = [];
          transIndex = -this.TRANSITION_FIELDS;
          cyc = void 0;
          prevValue = null;
          prevValid = true;
          conditions = [];
          ref2 = sig.conditions;
          for (j = 0, len1 = ref2.length; j < len1; j++) {
            condSig = ref2[j];
            conditions.push({
              trans: condSig.transitions,
              transIndex: -this.TRANSITION_FIELDS,
              offset: sig.cycle - condSig.cycle,
              nextCycle: null
            });
          }
          while (true) {
            nextCycle = origTransCycle = origTrans[transIndex + this.TRANSITION_FIELDS];
            for (m = 0, len2 = conditions.length; m < len2; m++) {
              cond = conditions[m];
              condCycle = cond.trans[cond.transIndex + this.TRANSITION_FIELDS];
              if (typeof condCycle !== "undefined") {
                cond.nextCycle = cyc = condCycle + cond.offset;
                if ((typeof nextCycle === "undefined") || (cyc < nextCycle)) {
                  nextCycle = cyc;
                }
              }
            }
            if (typeof nextCycle === "undefined" || nextCycle > this.endCycle) {
              break;
            }
            if (origTransCycle === nextCycle) {
              transIndex += this.TRANSITION_FIELDS;
            }
            valid = true;
            for (n = 0, len3 = conditions.length; n < len3; n++) {
              cond = conditions[n];
              if (cond.nextCycle === nextCycle) {
                cond.transIndex += this.TRANSITION_FIELDS;
              }
              condValid = cond.trans[cond.transIndex + 1];
              if (valid !== false) {
                if (condValid === "0") {
                  valid = false;
                } else {
                  if (typeof condValid === "undefined") {
                    valid = void 0;
                  }
                }
              }
            }
            if ((origTrans[transIndex + 1] !== prevValue) || (valid !== prevValid)) {
              prevValue = origTrans[transIndex + 1];
              prevValid = valid;
              newTrans.push(nextCycle, prevValue, prevValid);
            }
          }
          results.push(sig._setTransitions(newTrans, this.computeAnchors(newTrans)));
        } else {
          results.push(void 0);
        }
      }
      return results;
    };

    return WaveData;

  })();

  define(function(require, exports, module) {
    var $;
    $ = require("jquery");
    Utils = require("Utils");
    Variable = require("VCD/Variable");
    ScopeVariable = require("VCD/ScopeVariable");
    SignalValue = require("VCD/SignalValue");
    $.extend(WaveData.prototype, module.config());
    return WaveData;
  });

}).call(this);
