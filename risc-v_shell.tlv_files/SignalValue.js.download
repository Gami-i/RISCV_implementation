(function() {
  var $, SignalValue, Utils, ref;

  ref = [], $ = ref[0], Utils = ref[1];


  /*
  Class representing a signal at a cycle. This class is the primary class used to interact with data from the trace.
  
  TODO: Cycle number is relative to the signal in the trace. This should not be exposed to the user as it is
  not timing-abstract. We should expose a cycle number that is reflective of the phase of the \viz block in which
  this is declared, or extend this class with another that does.
  TODO: Add caching of signal values. Add a class for a signal value (not associated with wave, and static),
  cached in different formats. Change transactions to point to signal values. Keep a structure of all active
  values with one object per value. For each new value in the trace, lookup this structure and allocate
  if miss. Not sure whether value should include valid.
   */

  SignalValue = (function() {
    SignalValue.prototype.signal = null;

    SignalValue.prototype.transitions = null;

    SignalValue.prototype.cyc = -1;

    SignalValue.prototype.transIndex = null;

    SignalValue.TIME_SLOT_WIDTH = null;

    SignalValue.TRANSITION_FIELDS = null;

    SignalValue.staticInit = function(TSW, TF) {
      SignalValue.TIME_SLOT_WIDTH = TSW;
      return SignalValue.TRANSITION_FIELDS = TF;
    };


    /*
    @param {Object} signal the signal for this SignalValue
    @param {Number} cyc the starting cycle for this SignalValue
     */

    function SignalValue(signal, cyc1) {
      this.signal = signal;
      this.cyc = cyc1;
      this.transitions = this.signal.transitions;
      this.jumpTo(this.cyc);
    }

    SignalValue.prototype.getValue = function() {
      return this.transitions[this.transIndex + 1];
    };

    SignalValue.prototype.getValueStr = function() {
      return this.transitions[this.transIndex + 1];
    };

    SignalValue.prototype.getLegacyValue = function() {
      var ret;
      ret = this.getValue();
      if (!this.isValid()) {
        ret = "W" + ret;
      }
      return ret;
    };

    SignalValue.prototype.getPrevTransitionLegacyValue = function() {
      var ret;
      ret = this.getPrevTransitionValueStr();
      if (typeof ret === "undefined") {
        return void 0;
      }
      if (!this.isPrevTransitionValid()) {
        ret = "W" + ret;
      }
      return ret;
    };

    SignalValue.prototype.getNextTransitionLegacyValue = function() {
      var ret;
      ret = this.getNextTransitionValueStr();
      if (typeof ret === "undefined") {
        return void 0;
      }
      if (!this.isNextTransitionValid()) {
        ret = "W" + ret;
      }
      return ret;
    };

    SignalValue.prototype.getCycle = function() {
      return this.cyc;
    };


    /*
    @return {Boolean} true if current cycle is off the end of the trace.
     */

    SignalValue.prototype.offEnd = function() {
      return typeof this.cyc === "undefined" || this.cyc > this.signal.waveData.endCycle;
    };


    /*
    @return {Boolean} true if current cycle is off the beginning of the trace.
     */

    SignalValue.prototype.offBegining = function() {
      return typeof this.cyc === "undefined" || this.cyc < this.signal.waveData.startCycle;
    };


    /*
    @return {Boolean} true if current cycle is within (inclusive) the bounds of this trace.
     */

    SignalValue.prototype.inTrace = function() {
      return typeof this.cyc !== "undefined" && this.cyc <= this.signal.waveData.endCycle && this.cyc >= this.signal.waveData.startCycle;
    };


    /*
    Gets the cycle of the transition to the current value.
    @return {Number} the next (phase-granular) cycle
     */

    SignalValue.prototype.getTransitionCycle = function() {
      return this.transitions[this.transIndex];
    };


    /*
    Gets the next value string (as in VCD) of this signal
    @return {String, undefined} the next value
     */

    SignalValue.prototype.getNextTransitionValueStr = function() {
      return this.transitions[this.transIndex + SignalValue.TRANSITION_FIELDS + 1];
    };


    /*
    Gets the cycle of the next transition of this signal
    @return {Number} the next (phase-granular) cycle
     */

    SignalValue.prototype.getNextTransitionCycle = function() {
      return this.transitions[this.transIndex + SignalValue.TRANSITION_FIELDS];
    };


    /*
    Gets the previous value string (as in VCD) of this signal
    @return {String, undefined} the previous value (last transition)
     */

    SignalValue.prototype.getPrevTransitionValueStr = function() {
      return this.transitions[this.transIndex - SignalValue.TRANSITION_FIELDS + 1];
    };


    /*
    Gets the previous validity of this signal
    @return {Boolean, undefined} the validity of the value prior to the transition to the current value.
     */

    SignalValue.prototype.isPrevTransitionValid = function() {
      return this.transitions[this.transIndex - SignalValue.TRANSITION_FIELDS + 2];
    };


    /*
    Gets the validity of this signal after the next transition.
    @return {Boolean, undefined} the validity of the value after the next transition.
     */

    SignalValue.prototype.isNextTransitionValid = function() {
      return this.transitions[this.transIndex + SignalValue.TRANSITION_FIELDS + 2];
    };


    /*
    Is this signal valid (according to when conditions).
     */

    SignalValue.prototype.isValid = function() {
      return this.transitions[this.transIndex + 2];
    };


    /*
    Step to the given cycle (forward or backward).
    Same result as jumpToCycle(cycle), but it walks transitions, rather than jumping
    through anchor points, so it is best for small deltas.
    @param {int} cyc
    @return @ (for chaining)
     */

    SignalValue.prototype.stepTo = function(cyc) {
      var c, forward;
      forward = cyc > this.cyc;
      if (forward) {
        while ((typeof (c = this.getNextTransitionCycle()) !== "undefined") && c <= cyc) {
          this.transIndex += SignalValue.TRANSITION_FIELDS;
        }
      } else {
        while (this.transIndex >= 0 && this.getTransitionCycle() > cyc) {
          this.transIndex -= SignalValue.TRANSITION_FIELDS;
        }
      }
      this.cyc = cyc;
      return this;
    };


    /*
    Go to the given cycle as efficiently as possible.
    @param {int} cyc the cycle to go to.
    @return @ (for chaining)
     */

    SignalValue.prototype.goTo = function(cyc) {
      if (typeof this.transitions[this.transIndex] === "undefined" || Math.abs(cyc - this.cyc) > this.TIME_SLOT_WIDTH) {
        this.jumpTo(cyc);
      } else {
        this.stepTo(cyc);
      }
      return this;
    };


    /*
    Go to the beginning of the trace.
    @return @ (for chaining)
     */

    SignalValue.prototype.goToSimStart = function() {
      this.goTo(this.signal.waveData.startCycle);
      return this;
    };


    /*
    Go to the beginning of the trace.
    @return @ (for chaining)
     */

    SignalValue.prototype.goToSimEnd = function() {
      this.goTo(this.signal.waveData.endCycle);
      return this;
    };


    /*
    Increment the current cycle by the given amount (positive or negative)
    (as efficiently as possible).
    @param {int} cyc
    @return @ (for chaining)
     */

    SignalValue.prototype.step = function(cyc) {
      if (cyc == null) {
        cyc = 1;
      }
      return this.goTo(this.cyc + cyc);
    };


    /*
    Step forward (positive) or backward (negative) the given number of transitions (value changes).
    @param {int} steps the number of transitions to step
    @return {SignalValue} this {SignalValue} (for chaining)
     */

    SignalValue.prototype.stepTransition = function(steps) {
      if (steps == null) {
        steps = 1;
      }
      this.transIndex += SignalValue.TRANSITION_FIELDS * steps;
      this.cyc = this.getTransitionCycle();
      return this;
    };


    /*
    Step forward at least one cycle until the signal's value asInt is the given value
    or the end of the trace is reached (stopping offEnd).
    @param {int} val the signal value to step to
    @return {boolean} true on success
     */

    SignalValue.prototype.forwardToValue = function(val) {
      this.step();
      while (!this.offEnd()) {
        if (this.asInt() === val) {
          return true;
        }
        this.stepTransition();
      }
      return false;
    };


    /*
    Step backward at least one cycle until the signal's value asInt is the given value
    or the beginning of the trace is reached (stopping offBeginning).
    @param {int} val the signal value to step to
    @return {boolean} true on success
     */

    SignalValue.prototype.backToValue = function(val) {
      this.step(-1);
      while (!this.offBegining()) {
        if (this.asInt() === val) {
          return true;
        }
        this.stepTransition(-1);
      }
      return false;
    };

    SignalValue.prototype.goToNextValue = function() {
      return this.goToNextTransition();
    };

    SignalValue.prototype.goToPrevValue = function() {
      return this.goToPrevTransition();
    };

    SignalValue.prototype.nextCycle = function() {
      return this.goToNextCycle();
    };

    SignalValue.prototype.prevCycle = function() {
      return this.goToNextCycle();
    };

    SignalValue.prototype.asFixed = function(places, def) {
      return this.asRealFixed(places, def);
    };

    SignalValue.prototype.stepByCyc = function(cyc) {
      return this.step(cyc);
    };

    SignalValue.prototype.goToNextTransition = function() {
      return this.stepTransition(1);
    };

    SignalValue.prototype.goToPrevTransition = function() {
      return this.stepTransition(-1);
    };


    /*
    Get the signal value as a binary string with leading zeros.
    @param {Any} def the value to return if outside the bounds of the trace; undefined by default
    @return {String} the signal value as a string of binary bits, of def.
     */

    SignalValue.prototype.asBinaryStr = function(def) {
      if (!this.inTrace()) {
        return def;
      }
      return this.getValueStr();
    };


    /*
    Get the signal value as a string of hexadecimal digits, w/ X for digits with all x bits and x for
    digits with any x bits.
    @param {String} leadingZeroStr the string to include for each leading zero, such as ("0", " ", or "").
    @param {Any} def the value to return if outside the bounds of the trace; undefined by default
    @return {String} the hexadecimal string
     */

    SignalValue.prototype.asHexStr = function(leadingZeroSt, def) {
      if (!this.inTrace()) {
        return def;
      }
      return Utils.unwrittenCode();
    };


    /*
    Get the signal value as a decimal string.
    @param {String} leadingZeroStr the string to include for each leading zero, such as ("0", " ", or ""),
                    for any digits required to represent the maximum possible value.
    @param {Boolean} signed (optional) true to treat the leading bit as a sign bit. Default: false.
    @param {Any} def the value to return if outside the bounds of the trace; undefined by default
    @return {String} the decimal string representing the signal value
     */

    SignalValue.prototype.asIntStr = function(leadingZeroStr, signed, def) {
      if (!this.inTrace()) {
        return def;
      }
      return Utils.unwrittenCode();
    };


    /*
    Get the signal value interpreted as a SystemVerilog string type.
    @param {Any} def the value to return if outside the bounds of the trace; undefined by default
    @return {String} the value of the signal interpreted as a SystemVerilog string.
     */

    SignalValue.prototype.asString = function(def) {
      var binaryStr, ch, charBinaryStr, len, ret;
      if (!this.inTrace() || (this.signal.width % 8) !== 0) {
        return def;
      }
      len = this.signal.width / 8;
      binaryStr = this.asBinaryStr();
      ret = "";
      ch = 0;
      while (ch < len) {
        charBinaryStr = binaryStr.substring(ch * 8, (ch + 1) * 8);
        ret += String.fromCharCode(parseInt(charBinaryStr, 2));
        ch++;
      }
      return ret;
    };


    /*
    Get the signal value as a boolean, or null if dont-care or not a single bit.
    @param {Any} def the value to return if outside the bounds of the trace; undefined by default
    @return {Boolean} the signal value as a boolean or null
     */

    SignalValue.prototype.asBool = function(def) {
      if (!this.inTrace()) {
        return def;
      }
      if (this.getValueStr() === "0") {
        return false;
      } else {
        if (this.getValueStr() === "1") {
          return true;
        } else {
          return null;
        }
      }
    };


    /*
    Get the signal value as an integer, or NaN if value contains dont-cares.
    @param {Any} def the value to return if outside the bounds of the trace; undefined by default
    @return {int} the value of the signal
     */

    SignalValue.prototype.asInt = function(def) {
      if (!this.inTrace()) {
        return def;
      }
      return parseInt(this.getValueStr(), 2);
    };


    /*
    Get the 64-bit signal interpreted as an SV "real" signal.
    @param {Any} def the value to return if outside the bounds of the trace; undefined by default
    @return {Number} the value of the signal interpreted as an IEEE 64-bit floating-point value
     */

    SignalValue.prototype.asReal = function(def) {
      var denorm, exp, expStr, frac, fracStr, ret, signStr, str;
      if (!this.inTrace()) {
        return def;
      }
      str = this.getValueStr();
      expStr = str.substring(1, 12);
      if (exp === "11111111111") {
        return 0/0;
      }
      denorm = exp === "00000000000";
      signStr = str.substring(0, 1);
      exp = parseInt(expStr, 2) - 1023;
      fracStr = str.substring(12);
      frac = parseInt((denorm ? fracStr + "0" : "1" + fracStr), 2);
      ret = frac * Math.pow(2, exp - 52);
      if (signStr === "1") {
        ret = -ret;
      }
      return ret;
    };


    /*
    Get the 64-bit signal interpreted as an SV "real", rounded to a fixed
    decimal place.
    @param {int} places the number of decimal places
    @param {Any} def the value to return if outside the bounds of the trace; undefined by default
    @return {Number} the value of the signal interpreted as an IEEE 64-bit floating-point value, rounded to
                     a fixed number of digits
     */

    SignalValue.prototype.asRealFixed = function(places, def) {
      return this.asReal(def).toFixed(places);
    };


    /*
    Jumps this SignalValue to the given cycle (via anchors array).
    @param {int} cyc the cycle to jump the SignalValue to
    @return @ for chaining
     */

    SignalValue.prototype.jumpTo = function(cyc) {
      this.transIndex = this.signal.getTransIndexOfCycle(cyc);
      this.cyc = cyc;
      return this;
    };

    return SignalValue;

  })();

  define(function(require, exports, module) {
    $ = require("jquery");
    Utils = require("Utils");
    $.extend(SignalValue.prototype, module.config());
    return SignalValue;
  });

}).call(this);
