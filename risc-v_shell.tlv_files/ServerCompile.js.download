(function() {
  var $, EventEmitter, NewServerCompile, Promise, RetroServerCompile, ServerCompile, ServerCompileWrapper, WaveData, io, ref,
    bind = function(fn, me){ return function(){ return fn.apply(me, arguments); }; },
    extend = function(child, parent) { for (var key in parent) { if (hasProp.call(parent, key)) child[key] = parent[key]; } function ctor() { this.constructor = child; } ctor.prototype = parent.prototype; child.prototype = new ctor(); child.__super__ = parent.prototype; return child; },
    hasProp = {}.hasOwnProperty;

  ref = [], $ = ref[0], Promise = ref[1], io = ref[2], WaveData = ref[3];

  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    Promise = require("bluebird");
    io = require("socket.io-client");
  }


  /*
  A module that uses the SandHost server to compile TL-Verilog and produces output.
  
  @abstract
  @extend EventEmitter
  @todo +outline Document emitted events.
  @todo +outline Test the entire file.
   */

  ServerCompile = (function() {
    function ServerCompile() {}

    ServerCompile.prototype.sentCompilations = 0;


    /*
    @return {Promise<ServerCompile>}
    @abstract
     */

    ServerCompile.prototype.init = function() {
      throw new Error("Unimplemented method.");
    };


    /*
    Sends TL-Verilog to the server to compile.
    @param {String} tlv the source code to compile
    @param {Function} cb called with no arguments after the compilation starts executing remotely.
     */

    ServerCompile.prototype.compile = function(tlv, cb) {
      throw new Error("Unimplemented method.");
    };


    /*
    Opens a window to display the statistics page.
     */

    ServerCompile.prototype.showStats = function() {
      throw new Error("Unimplemented method.");
    };


    /*
    Opens a window to display the statistics page.
     */

    ServerCompile.prototype.showResults = function() {
      throw new Error("Unimplemented method.");
    };


    /*
    Sends the number of compilations to Google Analytics.
     */

    ServerCompile.prototype.compileAnalytics = function() {
      if (typeof window.ga !== "function") {
        return;
      }
      return window.ga("send", {
        hitType: "event",
        eventCategory: "Projects",
        eventAction: "compile",
        eventValue: ++this.sentCompilations
      });
    };

    return ServerCompile;

  })();


  /*
  The original {ServerCompile} module, before the `results-cache` rewrite.  Depreciated, planned to be removed when
  `results-cache` and `project-compiler` have been finished.
  
  @extend ModuleConfigObject
  @extend EventEmitter
   */

  RetroServerCompile = (function(superClass) {
    extend(RetroServerCompile, superClass);

    function RetroServerCompile() {
      this.navTLV = bind(this.navTLV, this);
      this.vcd = bind(this.vcd, this);
      this.jsonParseModel = bind(this.jsonParseModel, this);
      this.graph = bind(this.graph, this);
      this.error = bind(this.error, this);
      return RetroServerCompile.__super__.constructor.apply(this, arguments);
    }

    RetroServerCompile.prototype.socket = null;

    RetroServerCompile.prototype.lastId = null;

    RetroServerCompile.prototype.lastNavTLV = null;

    RetroServerCompile.prototype.project = null;

    RetroServerCompile.prototype.init = function() {
      return this.io().then((function(_this) {
        return function() {
          return _this;
        };
      })(this));
    };

    RetroServerCompile.prototype.setProject = function(project) {
      this.project = project;
      this.socket.on("newcompile", (function(_this) {
        return function(id) {
          if (_this.project.vcd) {
            return _this.emit("verilator/done", {
              success: "success"
            });
          }
        };
      })(this));
      return this.project.on("vcd", (function(_this) {
        return function(vcd) {
          return _this.emit("vcd", vcd);
        };
      })(this));
    };

    RetroServerCompile.prototype.compile = function(tlv, cb) {
      var data, dot, sim;
      this.compileAnalytics();
      sim = true;
      dot = true;
      if (this.project != null) {
        sim = !this.project.vcd;
      }
      data = {
        source: tlv,
        sim: sim,
        dot: dot
      };
      return this.socket.emit("data", JSON.stringify(data), (function(_this) {
        return function(lastId) {
          _this.lastId = lastId;
          return cb(_this.lastId);
        };
      })(this));
    };

    RetroServerCompile.prototype.showStats = function() {
      return window.open("/compile/" + this.lastNavTLV + "/stats/");
    };

    RetroServerCompile.prototype.showResults = function() {
      return window.open("/compile/" + this.lastNavTLV + "/results/");
    };


    /*
    Configures Socket.io.
    @return {Promise<IO:Socket>}
    @private
     */

    RetroServerCompile.prototype.io = function() {
      return new Promise((function(_this) {
        return function(resolve, reject) {
          _this.socket = io("/sandpiper/compile/");
          _this.socket.on("newcompile", function(id) {
            _this.emit("newcompile", {
              compile: id
            });
            return _this.emit("m4/done", {
              compile: id
            });
          });
          _this.socket.on("err", _this.error);
          _this.socket.on("graph", _this.graph);
          _this.socket.on("parse model", _this.jsonParseModel);
          _this.socket.on("vcd", _this.vcd);
          _this.socket.on("navTLV", _this.navTLV);
          _this.socket.on("stdall", function(id, log) {
            if (id !== _this.lastId) {
              return;
            }
            return _this.emit("stdall/all", log);
          });
          _this.socket.on("makeout", function(id, log) {
            if (id !== _this.lastId) {
              return;
            }
            return _this.emit("makeout/all", log);
          });
          return resolve(_this.socket);
        };
      })(this));
    };


    /*
    Handles error responses from the server.
    @param {String} id the compilation ID associated with this run
    @param {String} type the stage that experienced an error
     */

    RetroServerCompile.prototype.error = function(type, id) {
      if (id !== this.lastId) {
        return;
      }
      switch (type) {
        case "graph":
          return this.emit("graphviz/done", {
            success: "failure"
          });
        case "graph-timeout":
          return this.emit("graphviz/done", {
            success: "failure",
            timeout: true
          });
        case "vcd":
          return this.emit("verilator/done", {
            success: "failure"
          });
        case "vcd-timeout":
          return this.emit("verilator/done", {
            success: "failure",
            timeout: true
          });
        case "compile":
          return this.emit("sandpiper/done", {
            success: "failure"
          });
        case "compile-timeout":
          return this.emit("sandpiper/done", {
            success: "failure",
            timeout: true
          });
        case "navtlv":
          return this.emit("sandpiper/done", {
            success: "failure"
          });
        case "navtlv-timeout":
          return this.emit("navtlv/done", {
            success: "failure",
            timeout: true
          });
      }
    };


    /*
    Handles graph responses from the server.
    @param {String} id the compilation ID associated with this run
    @param {String} graph the resulting graph
     */

    RetroServerCompile.prototype.graph = function(id, graph) {
      console.log("Got graph (response: " + id + ", stored id: " + this.lastId + ")");
      if (id !== this.lastId) {
        return;
      }
      if (graph === "") {
        this.emit("graph", graph);
        return this.emit("graphviz/done", {
          success: "failure"
        });
      } else {
        this.emit("graph", graph);
        return this.emit("graphviz/done", {
          success: "success"
        });
      }
    };


    /*
    Handles JSON Parse Model responses from the server.
    @param {String} id the compilation ID associated with this run
    @param {String} json the resulting JSON
     */

    RetroServerCompile.prototype.jsonParseModel = function(id, json) {
      if (id !== this.lastId) {
        return;
      }
      this.emit("parse model", JSON.parse(json));
      return this.emit("parse model/done", {
        success: "success"
      });
    };


    /*
    Handles vcd responses from the server.
    @param {String} id the compilation ID associated with this run
    @param {String} vcd the resulting VCD file
     */

    RetroServerCompile.prototype.vcd = function(id, vcd) {
      if (id !== this.lastId) {
        return;
      }
      this.emit("vcd", new WaveData(vcd));
      return this.emit("verilator/done", {
        success: "success"
      });
    };


    /*
    Handles navTLV responses from the server.
    @param {String} id the compilation ID associated with this run
    @param {String} navTLV the resulting HTML representation of the TLV code.
     */

    RetroServerCompile.prototype.navTLV = function(id, navTLV) {
      if (id !== this.lastId) {
        return;
      }
      this.lastNavTLV = id;
      this.emit("sandpiper/done", {
        success: "success"
      });
      return this.emit("navTLV", navTLV);
    };

    return RetroServerCompile;

  })(ServerCompile);


  /*
  The replacement {ServerCompile} to be used once `results-cache` and `project-compiler` are fully implemented.
   */

  NewServerCompile = (function(superClass) {
    extend(NewServerCompile, superClass);

    function NewServerCompile() {
      this.get = bind(this.get, this);
      return NewServerCompile.__super__.constructor.apply(this, arguments);
    }


    /*
    @property {String} a URL referring to a `results-cache` instance to fetch results from.
     */

    NewServerCompile.prototype.endpoint = "http://makerchip.com/results/";


    /*
    @property {IO:Socket} A connection to the compilation server
     */

    NewServerCompile.prototype.socket = null;


    /*
    @property {String} the ID of the last triggered compilation.
     */

    NewServerCompile.prototype.currentCompile = null;


    /*
    @property {String} the ID of the last compile that generated statistics.
     */

    NewServerCompile.prototype.statCompile = null;

    NewServerCompile.prototype.init = function() {
      return Promise.resolve(this.getEndpoint()).then((function(_this) {
        return function(endpoint) {
          return _this.endpoint = endpoint;
        };
      })(this)).then((function(_this) {
        return function() {
          return _this.subscribe();
        };
      })(this));
    };


    /*
    Determines the URL to use when connecting to a {ResultsCache} server over HTTP.
    @return {Promise<String>} the URL to use to connect to {ResultsCache}
     */

    NewServerCompile.prototype.getEndpoint = function() {
      return $.get("/results-endpoint/");
    };


    /*
    Provides a Socket.io connection to a {ResultsCache} server.
    @return {Socket.io} a Socket.io client connection
     */

    NewServerCompile.prototype.openSocket = function() {
      return io(this.endpoint);
    };


    /*
    Subscribe to the Socket.io connection from the results cache.
    @private
    @todo +outline Rethink stats (do we need 'generated' and 'output' to trigger 'statsCompile'?)
    @todo +later Implement `socket.on 'top.tlv/model'`
    @todo +later Implement `socket.on 'top.tlv/scrubbed'`
    @todo +later Implement `socket.on 'top.tlv/source'`
    @todo +local_compile Finish implementing `socket.on 'log/{stage}'`
     */

    NewServerCompile.prototype.subscribe = function() {
      var gotStats, i, len, ref1, stage;
      this.socket = this.openSocket();
      gotStats = (function(_this) {
        return function(data) {
          if (data.compile !== _this.currentCompile) {
            return;
          }
          return _this.statCompile = data.compile;
        };
      })(this);
      ref1 = ["m4", "sandpiper-graph", "graphviz", "sandpiper", "verilator"];
      for (i = 0, len = ref1.length; i < len; i++) {
        stage = ref1[i];
        this.socket.on(stage + "/done", (function(_this) {
          return function(data) {
            if (data.compile !== _this.currentCompile) {
              return;
            }
            return _this.emit(data.stage + "/done", data);
          };
        })(this));
      }
      this.socket.on("top.tlv/generated", gotStats);
      this.socket.on("top.tlv/output", gotStats);
      this.socket.on("top.tlv/stats", gotStats);
      this.socket.on("vcd", (function(_this) {
        return function(data) {
          if (data.compile !== _this.currentCompile) {
            return;
          }
          return _this.get("/compile/" + data.compile + "/simulation.vcd").then(function(vcd) {
            return _this.emit("vcd", new WaveData(vcd));
          });
        };
      })(this));
      this.socket.on("top.tlv/graph", (function(_this) {
        return function(data) {
          if (data.compile !== _this.currentCompile) {
            return;
          }
          return _this.get("/compile/" + data.compile + "/top.tlv/graph.svg").then(function(graph) {
            return _this.emit("graph", graph);
          });
        };
      })(this));
      this.socket.on("top.tlv/nav", (function(_this) {
        return function(data) {
          if (data.compile !== _this.currentCompile) {
            return;
          }
          return _this.get("/compile/" + data.compile + "/top.tlv/navigable.tlv.html").then(function(nav) {
            return _this.emit("navTLV", nav);
          });
        };
      })(this));
      this.socket.on("log/sandpiper", (function(_this) {
        return function(data) {
          if (data.compile !== _this.currentCompile) {
            return;
          }
          return _this.emit("stdall", data);
        };
      })(this));
      return this.socket.on("log/verilator", (function(_this) {
        return function(data) {
          if (data.compile !== _this.currentCompile) {
            return;
          }
          return _this.emit("makeout", data);
        };
      })(this));
    };


    /*
    Get the result file from a compile run.
     */

    NewServerCompile.prototype.get = function(url) {
      var base;
      base = this.endpoint.replace(/\/$/, '');
      return Promise.resolve($.get("" + base + url));
    };


    /*
    @todo Add proper metadata, etc.
    @todo Parameterize `/makerchip/compile/`?
    @todo Finish creating multipart/form-data, or switch directly to {CompileProject}
    @todo Switch to using {CompileProject}
    @todo parse output (set `currentCompile`, etc.)  Also emit `newcompile` event?
    @todo Switch to Promise response?
    @todo Test compilation sending
     */

    NewServerCompile.prototype.compile = function(tlv, cb) {
      var project;
      this.compileAnalytics();
      project = {
        files: {
          "top.tlv": {
            type: "file",
            contents: tlv
          }
        },
        metadata: {},
        settings: {}
      };
      return $.post("/makerchip/compile/", project).then(function(data) {
        return cb(null, data);
      })["catch"](function(err) {
        return cb(err);
      });
    };


    /*
    @throws {ServerCompile.NoSuccessfulCompile} if there haven't been any compilations that generated statistics.
    @todo handle error case
     */

    NewServerCompile.prototype.showStats = function() {
      if (!this.statCompile) {
        throw new ServerCompile.NoSuccessfulCompile("No successful compile yet.");
      }
      return window.open(this.endpoint + "/compile/" + this.successfulCompile + "/top.tlv/stats/");
    };


    /*
    @throws {ServerCompile.NoSuccessfulCompile} if there haven't been any compilations that generated statistics.
    @todo handle error case
     */

    NewServerCompile.prototype.showResults = function() {
      if (!this.statCompile) {
        throw new ServerCompile.NoSuccessfulCompile("No successful compile yet.");
      }
      return window.open(this.endpoint + "/compile/" + this.successfulCompile + "/top.tlv/");
    };

    return NewServerCompile;

  })(ServerCompile);


  /*
  Temporary wrapper that determines if {RetroServerCompile} or {NewServerCompile} should be used.
  To be removed once {RetroServerCompile} is no longer needed.
   */

  ServerCompileWrapper = (function(superClass) {
    extend(ServerCompileWrapper, superClass);

    function ServerCompileWrapper() {
      return ServerCompileWrapper.__super__.constructor.apply(this, arguments);
    }

    ServerCompileWrapper.prototype.init = function() {
      return Promise.resolve(this.getEndpoint()).then((function(_this) {
        return function(endpoint) {
          var implementation;
          implementation = endpoint === "RETRO" ? RetroServerCompile : NewServerCompile;
          _this.instance = new implementation();
          _this.on = _this.instance.on;
          _this.emit = _this.instance.emit;
          _this.compile = function() {
            var ref1;
            return (ref1 = _this.instance).compile.apply(ref1, arguments);
          };
          return _this.instance.init();
        };
      })(this));
    };


    /*
    Determines the URL to use when connecting to a {ResultsCache} server over HTTP.
    @return {Promise<String>} the URL to use to connect to {ResultsCache}
     */

    ServerCompileWrapper.prototype.getEndpoint = function() {
      return $.get("/results-endpoint/");
    };

    return ServerCompileWrapper;

  })(ServerCompile);

  if ((typeof module !== "undefined" && module !== null ? module.exports : void 0) != null) {
    EventEmitter = require("events");
    ServerCompile.prototype = Object.assign(Object.create(EventEmitter.prototype), ServerCompile.prototype);
    NewServerCompile.prototype = Object.assign(Object.create(ServerCompile.prototype), NewServerCompile.prototype);
    RetroServerCompile.prototype = Object.assign(Object.create(ServerCompile.prototype), RetroServerCompile.prototype);
    ServerCompileWrapper.prototype = Object.assign(Object.create(ServerCompile.prototype), ServerCompileWrapper.prototype);
    module.exports = {
      ServerCompile: ServerCompile,
      RetroServerCompile: RetroServerCompile,
      NewServerCompile: NewServerCompile,
      ServerCompileWrapper: ServerCompileWrapper
    };
  } else {
    define("ServerCompile", function(require, exports, module) {
      $ = require("jquery");
      Promise = require("bluebird");
      io = require("socket.io");
      EventEmitter = require("ServerCompile/eventemitter");
      WaveData = require("VCD");
      $.extend(ServerCompile.prototype, EventEmitter.prototype, module.config());
      NewServerCompile.prototype = $.extend({}, Object.create(ServerCompile.prototype), NewServerCompile.prototype);
      RetroServerCompile.prototype = $.extend({}, Object.create(ServerCompile.prototype), RetroServerCompile.prototype);
      ServerCompileWrapper.prototype = $.extend({}, Object.create(ServerCompile.prototype), ServerCompileWrapper.prototype);
      return ServerCompileWrapper;
    });
  }

}).call(this);
